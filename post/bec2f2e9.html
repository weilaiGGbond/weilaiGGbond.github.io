<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端面经-前端基础 | webbond の 博客</title><meta name="author" content="webbond"><meta name="copyright" content="webbond"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="HTML+CSS 问答HTML5 新特性 语义化标签：根据内容的结构化选择合适的标签  语义化标签有利于 SEO 搜索引擎优化，同时增加代码的可读性和更利于代码维护  常见的语义化标签有: header nav main section aside footer  音频、视频标签：audio、video 数据存储：localStorage、sessionStorage canvas （画布）、Hi">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面经-前端基础">
<meta property="og:url" content="https://weilaiggbond.github.io/post/bec2f2e9.html">
<meta property="og:site_name" content="webbond の 博客">
<meta property="og:description" content="HTML+CSS 问答HTML5 新特性 语义化标签：根据内容的结构化选择合适的标签  语义化标签有利于 SEO 搜索引擎优化，同时增加代码的可读性和更利于代码维护  常见的语义化标签有: header nav main section aside footer  音频、视频标签：audio、video 数据存储：localStorage、sessionStorage canvas （画布）、Hi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://weilaiggbond.github.io/img/cover-one.png">
<meta property="article:published_time" content="2025-03-15T12:02:27.000Z">
<meta property="article:modified_time" content="2025-05-26T06:27:10.277Z">
<meta property="article:author" content="webbond">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="css">
<meta property="article:tag" content="html">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://weilaiggbond.github.io/img/cover-one.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "前端面经-前端基础",
  "url": "https://weilaiggbond.github.io/post/bec2f2e9.html",
  "image": "https://weilaiggbond.github.io/img/cover-one.png",
  "datePublished": "2025-03-15T12:02:27.000Z",
  "dateModified": "2025-05-26T06:27:10.277Z",
  "author": [
    {
      "@type": "Person",
      "name": "webbond",
      "url": "https://weilaiggbond.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://weilaiggbond.github.io/post/bec2f2e9.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面经-前端基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: rgb(247, 249, 254);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover-one.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avatar.jpg" alt="Logo"><span class="site-name">webbond の 博客</span></a><a class="nav-page-title" href="/"><span class="site-name">前端面经-前端基础</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">前端面经-前端基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-15T12:02:27.000Z" title="发表于 2025-03-15 20:02:27">2025-03-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-26T06:27:10.277Z" title="更新于 2025-05-26 14:27:10">2025-05-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h4 id="HTML-CSS-问答"><a href="#HTML-CSS-问答" class="headerlink" title="HTML+CSS 问答"></a>HTML+CSS 问答</h4><h4 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h4><ul>
<li>语义化标签：根据内容的结构化选择合适的标签</li>
</ul>
<font style="color:#DF2A3F;">语义化标签有利于 SEO 搜索引擎优化，同时增加代码的可读性和更利于代码维护</font>

<p>常见的语义化标签有: <code>header</code> <code>nav</code> <code>main</code> <code>section</code> <code>aside</code> <code>footer</code></p>
<ul>
<li>音频、视频标签：<code>audio</code>、<code>video</code></li>
<li>数据存储：<code>localStorage</code>、<code>sessionStorage</code></li>
<li><code>canvas （画布）</code>、<code>History API 路由跳转</code>、<code>websocket（通信协议）</code></li>
<li><code>input</code>标签新增属性：<code>placeholder</code>、<code>autocomplete</code>、<code>autofocus</code>、<code>required</code></li>
<li><code>DOM</code>查询方式：<code>document.querySelector()</code>、<code>documnet.querySelectorAll()</code></li>
</ul>
<h4 id="src-和-href-之间的区别"><a href="#src-和-href-之间的区别" class="headerlink" title="src 和 href 之间的区别"></a>src 和 href 之间的区别</h4><p>src 表示对资源的引用，将指向的内容嵌入当前标签所在的位置，src 会将其指向的资源<font style="color:#DF2A3F;">下载</font>并应用到文档内，当浏览器解析到该元素时，会暂停其他资源的下载和处理，因此<font style="color:#DF2A3F;"> <code>src</code> 会阻塞文档的解析过程</font></p>
<p>href 表示超文本引用，将指向的网络资源和当前元素建立链接关系，当浏览器识别到它指向的文件时，就会并行下载资源，不会停止对当前文档的处理</p>
<h4 id="行内元素和块级元素"><a href="#行内元素和块级元素" class="headerlink" title="行内元素和块级元素"></a>行内元素和块级元素</h4><p>行内元素：<code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>input</code> <code>select</code> <code>strong</code></p>
<p>块级元素：<code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code> <code>h5</code> <code>h6</code> <code>p</code></p>
<h4 id="谈谈-vmin-和-vmax"><a href="#谈谈-vmin-和-vmax" class="headerlink" title="谈谈 vmin 和 vmax"></a>谈谈 vmin 和 vmax</h4><ul>
<li><strong><code>vmin</code></strong>：它代表视口宽度和高度中较小值的 1%。例如，如果视口的宽度是 800px，高度是 600px，那么 1vmin 就等于 6px（因为 600px 是较小值，600×1% = 6px）。</li>
<li><strong><code>vmax</code></strong>：它代表视口宽度和高度中较大值的 1%。在上述例子中，1vmax 就等于 8px（因为 800px 是较大值，800×1% = 8px）。</li>
</ul>
<h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p><code>display:none</code> 元素会完全<font style="color:#DF2A3F;">从文档流中移除</font>并且<font style="color:#DF2A3F;">不会出现在渲染树</font>中，不占据任何空间</p>
<p><code>display:inline</code> 元素按行内元素排列，<font style="color:#DF2A3F;">宽度由内容决定，不可设置宽高，可以设置水平方向的边距</font></p>
<p><code>display:inline-block</code> 设置元素为行内块元素，元素按行内元素，但<font style="color:#DF2A3F;">可以设置宽高和边距</font></p>
<p><code>display:block</code> 元素<font style="color:#DF2A3F;">独占一行</font>，可以设置宽高和边距</p>
<p><code>display:flex</code> 启动<font style="color:#DF2A3F;">弹性盒子布局</font>，子元素<font style="color:#DF2A3F;">按主轴/交叉轴排列</font></p>
<p><code>display:grid</code> 启动<font style="color:#DF2A3F;">网格布局</font>，通过<font style="color:#DF2A3F;">行和列定义复杂的二维布局</font>结构</p>
<p><code>display:contents</code> <font style="color:#DF2A3F;">元素本身不渲染</font>，但其<font style="color:#DF2A3F;">子元素会正常显示</font></p>
<p><code>display:inline-flex</code> 行内弹性盒子，外部表现为<code>inline</code>，内部为<code>flex</code></p>
<p><code>display:inline-grid</code> 行内网格，外部表现为<code>inline</code>，内部为<code>grid</code></p>
<h4 id="Flex-和-Gird-布局"><a href="#Flex-和-Gird-布局" class="headerlink" title="Flex 和 Gird 布局"></a>Flex 和 Gird 布局</h4><p><strong>Flex</strong></p>
<p>容器属性：</p>
<p><code>flex-direction 主轴方向</code> <code>flex-warp 是否换行</code></p>
<p><code>justify-content 主轴对齐方式</code> <code>align-items 交叉轴对齐方式</code></p>
<p>项目属性</p>
<p><code>flex-grow 放大比例</code> <code>flex-shrink 缩小比例</code> <code>flex-basis 项目占据的空间大小</code></p>
<p><code>align-self 垂直对齐单个子项</code></p>
<p><code>flex:1</code> == <code>flex-grow:1; flex-shrink:1; flex-basis:0;</code></p>
<p>表示当前子元素<font style="color:#DF2A3F;">自动填充剩余空间</font></p>
<p><code>flex:2</code></p>
<p>表示当前子元素<font style="color:#DF2A3F;">自动填充剩余空间的 2 倍</font></p>
<p><code>flex:auto</code> == <code>flex-grow:1; flex-shrink:1; flex-basis:auto;</code></p>
<p>表示子元素<font style="color:#DF2A3F;">按照宽度比例分配剩余空间大小</font></p>
<p><strong>grid</strong></p>
<p>容器属性：</p>
<p><code>grid-template-columns 网格的列宽</code> <code>grid-template-rows 网格的行高</code></p>
<p>比例分配：<code>100px 1fr 2fr</code> ;重复模式：<code>repeat(3,1fr);</code>最大和最小宽度：<code>minmax(200px;auto)</code></p>
<p><code>gap 行列间的间距</code></p>
<p><code>grid-template-areas 通过命名定义布局</code></p>
<p><code>justify-content 水平对齐网格方式</code></p>
<p><code>align-items 垂直对齐网格方式</code></p>
<p>项目属性</p>
<p><code>grid-area 指定命名</code></p>
<p><code>justify-self 水平对齐单个子项</code></p>
<p><code>align-self 垂直对齐单个子项</code></p>
<h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><p>盒模型组成部分：<code>content</code> <code>padding</code> <code>border</code> <code>margin</code></p>
<p>盒模型可以分为标准盒模型（<code>content-box</code>）和 IE 盒模型(<code>border-box</code>)，两者的区别是标准盒模型的宽高<font style="color:#DF2A3F;">不包括内边距（<code>padding</code>）和边框（<code>border</code>）</font>，IE 盒模型的宽高<font style="color:#DF2A3F;">包括内边距（<code>padding</code>）和边框（<code>border</code>）</font></p>
<font style="color:#F1A2AB;">这也就是为什么 IE 盒模型需要将 box-sizing 设置为 border-box
</font>

<p><code>box-sizeing:content-box;</code>(标准盒模型) <code>box-sizeing:border-box;</code>(IE 盒模型)</p>
<h4 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h4><p>伪元素指的是在内容元素的前后插入额外的元素或样式，但这些元素实际上并不在文档中生成。伪类指的是将一些特殊的效果添加到特定选择器上，添加新的样式。</p>
<p>常见的伪元素：<code>::before</code> <code>::after</code></p>
<p>常见的伪类： <code>:link</code> <code>:visited</code> <code>:hover</code> <code>:active</code></p>
<h4 id="文本溢出"><a href="#文本溢出" class="headerlink" title="文本溢出"></a>文本溢出</h4><p>单行文本溢出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-ellipsis</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: no-warp;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多行文本溢出</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-ellipsis</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  -webkit-<span class="attribute">box-orient</span>: vertical;</span><br><span class="line">  -webkit-<span class="selector-tag">line</span>-clamp: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><p>使用绝对定位</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  transfrom: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>margin:auto</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="comment">/* 适用于块元素 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: (父元素height-子元素height)/<span class="number">2</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>flex 布局</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>text-align:center</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="comment">/* 适用于文本元素 */</span></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: 父元素高度;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="谈谈你对-BFC-的理解"><a href="#谈谈你对-BFC-的理解" class="headerlink" title="谈谈你对 BFC 的理解"></a>谈谈你对 BFC 的理解</h4><p>BFC 指的是块格式化上下文，是布局过程中生成块级盒子的区域，也是浮动元素和其他元素的交互限定区域</p>
<font style="color:#DF2A3F;">创建 BFC 的条件</font>

<ul>
<li>元素设置浮动</li>
<li>元素设置绝对定位 <code>position:absolute/fixed</code></li>
<li><code>display</code>值为： <code>inline-block</code>、<code>flex</code>、<code>table-cell</code></li>
<li><code>overflow</code>值为：<code>hidden</code>、<code>auto</code>、<code>scroll</code></li>
</ul>
<h4 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h4><p>回流也称为重排，当<code>DOM</code>的变化影响到了元素的布局信息，浏览器需要重新计算元素在视口内的位置和大小信息，将其安放到页面中的过程称为回流</p>
<p>重绘是指一个元素的外观发生改变，但没有影响到布局信息时，浏览器就会将新样式应用到元素上，然后重新绘制该元素的外观，这个过程称为重绘</p>
<p>重排的触发条件：<strong>删除/添加可见的 DOM 元素</strong>、<strong>元素的尺寸改变</strong>、<strong>内容的改变</strong>、<strong>浏览器窗口尺寸改变</strong></p>
<p>重绘的触发条件：<strong>修改元素的外观属性</strong></p>
<p>优化建议：</p>
<p>避免频繁的对<code>DOM</code>进行操作，尽量批量修改以减少回流和重绘的次数</p>
<p>在操作元素前先将元素设置为<code>display:none</code>,在内存中进行操作后再添加到文档中</p>
<p>使用<code>transform</code>和<code>opacity</code>进行动画效果</p>
<p>避免频繁读取布局信息</p>
<h5 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h5><p><code>TypeScript</code>（简称 TS）是 <code>JavaScript</code> 的一个超集，主要为 <code>JavaScript</code> 添加了静态类型系统。TS 允许开发者为变量、函数参数、函数返回值等添加类型注解来明确数据的类型，还可以使用接口来定义对象的结构，描述对象应该具有哪些属性和方法，以及这些属性和方法的类型，也枚举类型用于定义一组命名的常量，提高了代码的类型安全。总体来说，<code>ts</code> 是对 <code>JS</code> 语言的补充，使得 <code>JS</code> 语言在开发时具有更强的可读性和可维护性</p>
<p>泛型允许开发者在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型在<code>typescript</code>中，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性</p>
<h4 id="TS-的工具类型有哪些？"><a href="#TS-的工具类型有哪些？" class="headerlink" title="TS 的工具类型有哪些？"></a>TS 的工具类型有哪些？</h4><p><code>Partial&lt;T&gt;</code>能够将类型 T 的所有属性变为可选属性</p>
<p><code>Required&lt;T&gt;</code>能够将类型 T 的所有可选属性变为必需属性</p>
<p><code>Pick&lt;T,K&gt;</code> 从类型 T 中选取一组属性 K 来构造一个新的类型</p>
<p><code>Omit&lt;T,K&gt;</code> 从类型 T 中移除一组属性 K 来构造一个新的类型</p>
<h4 id="type-和-interface-的区别"><a href="#type-和-interface-的区别" class="headerlink" title="type 和 interface 的区别"></a><code>type</code> 和 <code>interface</code> 的区别</h4><p><code>type</code> 和 <code>interface</code> 都是用于定义对象类型，但 <code>type</code> 常用于定义基本类型、联合类型、交叉类型等，但 <code>interface</code> 主要用于定义对象类型，而且 <code>type</code> 无法重复定义类型别名，但是 <code>interface</code> 可以重复定义，并且重复定义时会将属性进行合并。</p>
<h3 id="JS-问答"><a href="#JS-问答" class="headerlink" title="JS 问答"></a><code>JS</code> 问答</h3><h4 id="ES6-中的新特性"><a href="#ES6-中的新特性" class="headerlink" title="ES6 中的新特性"></a><code>ES6</code> 中的新特性</h4><p><code>ES6</code> 通常认为是在 <code>ES2015</code> 以及之后所有 <code>ES</code> 版本，是对 <code>JS</code> 语言的一次重大更新，使得前端语言在开发时更加简单和高效</p>
<ul>
<li><code>ES6</code> 中引入了 <code>let</code> 和 <code>const</code> 用于声明变量和常量，相较于之前的 <code>var</code> 而言，<code>let</code> 和 <code>const</code> 具有块级作用域 且不具有变量提升，解决了原先 <code>JS</code> 中出现的内部变量污染外部变量和用于循环引用的变量泄露等问题</li>
<li><code>ES6</code> 中还引入了箭头函数，与普通函数不同的是箭头函数在书写上更加简单，而且箭头函数是没有 <code>this</code> 和 <code>arguments</code> 参数的，它的 <code>this</code> 是通过捕获外部上下文中的 <code>this</code> 获取的，因此箭头函数不能作为构造函数使用以及不能修改它的 <code>this</code> 指向</li>
<li><code>ES6</code> 中还引入了 <code>class</code> 类的概念，使得 <code>JS</code> 语言能够更好的面向编程，而且还为类式继承和函数封装提供了新方法</li>
<li>为解决多个回调函数嵌套导致的回调地狱问题，<code>ES6</code> 引入了 <code>Promise</code>,这是一种异步编程的解决方案，它本质是一个构造函数，可以传入一个函数，返回一个 <code>Promise</code> 实例，<code>Promise</code> 实例一共有三个状态：<code>pending</code>、<code>fullfilled</code>、<code>rejected</code>，分别代表实例执行中、已成功、已失败的状态，<code>Promise</code> 是通过<code>resolve()</code>和<code>reject()</code>方法来改变当前实例的状态的，当状态一旦改变就无法逆转或再次更改，可以通过<code>.then</code> 和<code>.catch</code> 调用执行成功和失败后的回调</li>
<li>模块化编程，<code>ES6</code> 中使用 <code>ES Module</code> 来进行模块的导入和导出，与之前的 <code>CommonJS</code> 不同的是 <code>ModuleJS</code> 对模块的导入是引入,而 <code>CommonJS</code> 对模块是进行浅拷贝，会更改导入模块的内容</li>
<li>模板字符串，<code>ES6</code> 中引入了模板字符串使得字符串拼接更加简单</li>
<li>扩展和剩余运算符，两者在形式上相同但扩展运算符常用于数组或对象的展开，而剩余运算符常用于函数中剩余参数的接收并将其转化成数组的形式</li>
<li><code>ES6</code> 中还引入了解构赋值的方法，它能够有针对性的从数组或对象中获取属性或方法，使得属性的获取更加的简单高效</li>
<li>此外 <code>ES6</code> 中还引入了两种新的数据结构 <code>Map</code> 和 <code>Set</code>，<code>map</code> 和 <code>Object</code> 有些类似，但是不同的是 <code>Object</code> 只能接受字符串或 <code>Symbol</code> 作为键名，而 map 可以将任意数据类型作为键名使用。Set 则是规定了一个没有重复数据的集合，使得数据操作更加简便</li>
<li>在 <code>ES9</code> 中还引入了 <code>async/await</code> 用来解决 <code>Promise</code> 的 <code>then</code> 链回调过多导致的语义不明的问题，<code>async/await</code> 能够将异步代码以同步的形式来书写，使得代码的可读性更强更利于维护</li>
<li>最后，<code>ES6</code> 中引入了 <code>Proxy</code> 用于数据代理，它主要接受两个参数，一个是需要代理的对象，一个是对对象执行的处理。在 <code>vue3</code> 中使用 <code>Proxy</code> 代替原来的 <code>Object.defineProperty</code> 实现对数据的劫持处理，使得数据代理更加高效而不需要重写数组方法。</li>
</ul>
<h4 id="如何让引用数据类型的属性不被修改"><a href="#如何让引用数据类型的属性不被修改" class="headerlink" title="如何让引用数据类型的属性不被修改"></a>如何让引用数据类型的属性不被修改</h4><ul>
<li>使用<code>Object.freeze</code>实现属性的浅冻结——只能冻结对象自身的属性，无法冻结嵌套对象（<font style="color:#DF2A3F;">使用<code>Object.isFrozen(obj)</code>解冻</font>）</li>
<li>使用<code>Object.defineProperty</code>修改属性描述符中的 <strong><code>configurable:false</code></strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;a&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">// 禁止修改</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="防抖和节流的区别"><a href="#防抖和节流的区别" class="headerlink" title="防抖和节流的区别"></a>防抖和节流的区别</h4><p><strong><font style="color:#DF2A3F;">防抖是在事件停止触发后执行最后一次操作，而节流是固定时间内只执行一次操作</font></strong></p>
<p>防抖常使用在输入框实时搜索，窗口<code>resize</code>事件，表单提交按钮防重复点击</p>
<p>节流常用于页面滚动加载更多，鼠标移动事件</p>
<h4 id="Ajax、Axios、fetch-之间的联系和区别"><a href="#Ajax、Axios、fetch-之间的联系和区别" class="headerlink" title="Ajax、Axios、fetch 之间的联系和区别"></a><code>Ajax、Axios、fetch</code> 之间的联系和区别</h4><p><strong><code>Ajax</code></strong>全称是 <font style="color:#DF2A3F;">异步<code>JavaScript</code>和<code>XML</code>，是利用浏览器内置的<code>XMLHttpRequest</code>对象实现的技术</font>，可以实现无需重新加载整个网页的情况下，更新部分网页，但是 <code>ajax</code> 基于原生的<code>xhr</code>开发，而且<font style="color:#DF2A3F;">配置和调用方式非常混乱，需要手动配置</font>，在多个回调函数嵌套调用时会出现<font style="color:#DF2A3F;">回调地狱</font>的问题</p>
<p><code>Fetch</code> 是<code>ES6</code>中引入的进行网络请求的新方法，<font style="color:#DF2A3F;">基于<code>Promise</code>设计</font>。与<code>ajax</code>不同的是<code>fetch</code>没有使用<code>XMLHttpRequest</code>对象，并且<font style="color:#DF2A3F;">语法简单更加语义化</font>，有丰富的<code>API</code>使用，且<font style="color:#DF2A3F;">支持流式处理能力</font>，但是<code>fetch</code>无法对返回的错误响应信息进行处理，而且<code>fetch</code>也<font style="color:#DF2A3F;">无法携带<code>cookie</code>需要手动配置，也不支持超时控制处理和检测请求的进度</font></p>
<p><code>Axios</code> 是基于<code>Promise</code>封装的 <code>HTTP</code> 客户端请求库，由浏览器端发起<code>XMLHttpRequests</code>请求能够携带<code>cookie</code>信息，并且基于<code>Promise</code>封装能够解决请求回调地狱的问题，能够<font style="color:#DF2A3F;">自动序列化<code>JSON</code>数据以及配置由全局的请求和响应拦截器，但是对于流式处理需要进行手动配置</font></p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是<font style="color:#DF2A3F;">内部函数有权访问外部函数作用域中的变量</font>。闭包常见的创建方式是通过<font style="color:#DF2A3F;">函数嵌套</font>，<font style="color:#DF2A3F;">内层函数引用外层函数的局部变量，并通过返回内层函数或在其他作用域调用它实现</font>。</p>
<p>闭包的优点是 能<strong>保留上下文</strong>和进行<strong>数据封装</strong>，避免全局变量污染局部变量，闭包常见的应用有 <strong>封装私有变量进行模块化开发</strong>、<strong>函数柯里化</strong>（将多参数转化成单参数链式调用）、<strong>防抖与节流</strong>等</p>
<h4 id="谈谈你对-this-的理解"><a href="#谈谈你对-this-的理解" class="headerlink" title="谈谈你对 this 的理解"></a>谈谈你对 <code>this</code> 的理解</h4><p><code>this</code> 是执行上下文中的一个动态绑定属性，它指向函数调用时的上下文对象</p>
<p>常见的判断 <code>this</code> 指向的方法有 4 种</p>
<ul>
<li><p><font style="color:#DF2A3F;">函数独立调用</font>：如果当前函数不是对象中的方法或者属性，当函数执行时 <code>this</code> 指向全局对象</p>
</li>
<li><p><font style="color:#DF2A3F;">对象方法调用</font>：如果当前函数是对象中的方法或属性，当调用该函数时 <code>this</code> 指向这个对象</p>
</li>
<li><p><font style="color:#DF2A3F;">构造器函数调用</font>：如果使用 new 去调用构造器函数，函数在执行前会创建一个新的对象，this 指向新创建的对象</p>
</li>
<li><p><font style="color:#DF2A3F;"><code>apply、call、bind</code> 方法调用</font>：三种方法都能够修改 <code>this</code> 的指向</p>
</li>
</ul>
<p><code>apply</code> 接收两个参数，第一个参数是 <code>this</code> 绑定的对象，第二个参数是传入绑定对象的参数数组，<code>call</code> 接收的第一个参数是 <code>this</code> 绑定的对象，剩余参数是传入函数执行的参数，<code>bind</code> 则是接收一个对象，返回一个绑定到对象上的新函数。</p>
<h4 id="原型链和继承"><a href="#原型链和继承" class="headerlink" title="原型链和继承"></a>原型链和继承</h4><p>在 <code>JS</code> 中每个对象都有一个内部属性<code>Prototype</code>，它指向该对象的原型对象，可以通过<code>__proto__</code>隐式原型来进行访问。又因为原型对象本质上也是对象，所以它也存在<code>Prototype</code>属性指向它的原型对象，以此类推这样形成的链式结构称为原型链。</p>
<p>当访问一个对象的属性和方法时，<code>JS</code> 就会先在该对象本身查找，如果找不到，就会沿着原型链向上查找，直到找到该属性或方法或者到达原型链的终点 <code>Object.prototype.__proto__ = null</code></p>
<p>继承是指<font style="color:#DF2A3F;">一个对象直接使用另一对象的属性和方法</font>，在 <code>JS</code> 中有多种实现继承的方式，原型链继承就是其中的一种</p>
<font style="color:#DF2A3F;">原型链继承</font>的原理是子类原型指向父类实例，继承父类原型属性，除了使用原型链实现继承外还可以使用<font style="color:#DF2A3F;">构造函数继承、组合继承、寄生组合继承、类式继承</font>等

<font style="color:#C1E77E;">除了使用原型链继承外还可以使用</font>

<p>原型链继承的原理是子类原型指向父类实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Father&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">showName</span>(); <span class="comment">// &#x27;Child&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">name</span>); <span class="comment">// &#x27;Child&#x27;</span></span><br><span class="line"><span class="comment">// 缺点：没有办法向父类构造函数传参</span></span><br></pre></td></tr></table></figure>
<p>构造函数继承原理是子类构造函数中调用父类构造函数，继承父类实例属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">showName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">//构造函数继承</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">child.<span class="title function_">showName</span>(); <span class="comment">// &#x27;Child&#x27;</span></span><br><span class="line"><span class="comment">// 缺点：没有办法继承父类原型上的方法</span></span><br></pre></td></tr></table></figure>
<p>组合继承原理是结合构造函数继承和原型链继承，进行缺点互补弥补不能向父类构造函数传参和不能调用父类原型上的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constuctor</span> = <span class="title class_">Child</span>;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">child.<span class="title function_">showName</span>();</span><br></pre></td></tr></table></figure>
<p>寄生组合继承原理是通过 <code>Object.create</code>继承父类原型，避免调用父类构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">child.<span class="title function_">showName</span>();</span><br></pre></td></tr></table></figure>
<p>类式继承的原理是<code>class</code> 和 <code>extends</code> 语法糖，底层基于的是<font style="color:#DF2A3F;">寄生组合继承</font></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;Child&quot;</span>);</span><br><span class="line">child.<span class="title function_">showName</span>();</span><br></pre></td></tr></table></figure>
<h4 id="事件捕获和事件冒泡以及事件委托的理解"><a href="#事件捕获和事件冒泡以及事件委托的理解" class="headerlink" title="事件捕获和事件冒泡以及事件委托的理解"></a>事件捕获和事件冒泡以及事件委托的理解</h4><p>事件捕获：事件从最外层的祖先元素开始触发，逐级向下传递到目标元素</p>
<p>事件冒泡：事件从最内层的目标元素开始触发，逐级向上传递至父元素、祖先元素，直到 <code>document</code> 或 <code>window</code>对象，常见的阻止事件冒泡的方法是使用<code>event.stopPropagation()</code></p>
<p>事件委托：利用事件冒泡机制，将子元素的事件处理逻辑绑定到父元素上，通过父元素统一管理子元素的事件，能够减少事件处理的数量，节省内存，更利于维护</p>
<p>DOM 事件流处理逻辑 ：事件捕获 -&gt; 目标元素 -&gt; 事件冒泡</p>
<h4 id="WebScoket-的理解"><a href="#WebScoket-的理解" class="headerlink" title="WebScoket 的理解"></a>WebScoket 的理解</h4><p><code>webScoket</code> 是一种基于 <code>TCP</code> 的全双工通信协议，旨在解决 <code>HTTP</code> 协议在实时通信中的局限性，最大的特点是 服务器可以向客户端主动推送消息，客户端也可以主动向服务器发送消息</p>
<p><code>webscoket</code> 原理：客户端向 <code>webScoket</code> 服务器通知一个带有所有接收者 <code>ID</code> 的事件，服务器接收后立即通知所有活跃的客户端，只有 <code>ID</code> 在接收者 <code>ID</code> 序列中的客户端才会处理这个事件</p>
<p><code>WebScoket</code> 连接的特点：</p>
<p>支持双向通信，实时性更强</p>
<p>可以发送文本，也可以发送二进制数据</p>
<p>建立在 <code>TCP</code> 协议上，服务端的实现比较容易</p>
<p>数据格式比较轻量，性能开销小，通信高效</p>
<p>没有同源限制，客户端可以与任意服务器通信</p>
<p>创建 <code>WebScoket</code> 实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://服务端webscoket地址&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>监听连接状态事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// 在客户端与服务端建立连接后触发</span></span><br><span class="line">socket.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">res</span>) &#123;&#125;; <span class="comment">// res.data 为收到的消息</span></span><br><span class="line">socket.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params">evt</span>) &#123;&#125;; <span class="comment">// 在客户端与服务端断开连接后触发</span></span><br><span class="line">socket.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">error</span>) &#123;&#125;; <span class="comment">// 在连接时发生错误时触发</span></span><br><span class="line">socket.<span class="title function_">send</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 向服务器端发送数据</span></span><br><span class="line">socket.<span class="title function_">close</span>(status, closeReasonMessage); <span class="comment">// 关闭连接请求</span></span><br></pre></td></tr></table></figure>
<h4 id="WebScoket-的心跳监测"><a href="#WebScoket-的心跳监测" class="headerlink" title="WebScoket 的心跳监测"></a><code>WebScoket</code> 的心跳监测</h4><p>在<code>webscoket</code>通信中，网络状态可能不稳定，比如出现丢包、网络抖动等情况，心跳监测的目的就是为了监控<code>webscoket</code>连接是否稳定，原理是客户端和服务器端定时互相发送特定的消息，通常是 10~30 秒，以此来确认双方的连接是否正常，如果在规定时间内没收到对方的心跳响应，就判定连接出现问题然后进行断线重连机制，重新建立<code>webscoket</code>连接，以保证通信的连续性，提升用户体验</p>
<h4 id="即时通信的方法以及区别"><a href="#即时通信的方法以及区别" class="headerlink" title="即时通信的方法以及区别"></a>即时通信的方法以及区别</h4><p><strong>短轮询和长轮询：</strong><font style="color:#DF2A3F;">短轮询</font><strong>是通过浏览器每隔一段时间向服务端发送 http 请求，在服务端收到请求后，不论是否有数据更新，都直接进行响应。本质上还是浏览器发送请求，服务器接收响应的过程，需要不断地建立 http 连接，严重浪费了服务器端和客户端地资源。</strong><font style="color:#DF2A3F;">长轮询</font>则是在服务器向客户端响应前先判断服务器端数据是否更新，如果一直没有数据更新，则到达一定时间限制才会返回。在客户端接收到数据并处理后再次发出请求，重新建立连接。与短轮询相比，长轮询减少了不必要的 http 请求次数，但仍然会导致资源的浪费</p>
<p><strong>SSE：</strong>服务器使用数据流的方式向客户端推送信息，服务器向客户端声明发送数据流，客户端不会关闭连接，一直接收服务器推送的消息。SSE 基于 http 协议，相对于轮询方法不需要建立过多的 http 请求，节约资源</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSource = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;/see-endpoint&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">withCredentials</span>:<span class="literal">true</span>; <span class="comment">// 携带cookie</span></span><br><span class="line">&#125;);</span><br><span class="line">eventSource.<span class="property">onopen</span> = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 建立连接的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">eventSource.<span class="property">onmesage</span> = <span class="function">(<span class="params">e</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>)</span><br><span class="line">&#125;</span><br><span class="line">eventSource.<span class="property">onerror</span> = <span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>webscoket：</strong>与传统的<code>http</code>协议不同，<code>webscoket</code>协议允许由服务器自动向客户端推送信息。使用<code>websocket</code>协议的缺点是在服务器端的配置比较复杂。<code>webscoket</code>是一个全双工的协议，通信双方可以相互发送消息，<code>SSE</code>的方式是单向通信的，只能由服务器端向客户端推送消息。</p>
<h4 id="浏览器事件循环和-NodeJS-事件循环的区别"><a href="#浏览器事件循环和-NodeJS-事件循环的区别" class="headerlink" title="浏览器事件循环和 NodeJS 事件循环的区别"></a>浏览器事件循环和 NodeJS 事件循环的区别</h4><p><strong>浏览器事件循环的核心作用是实现非阻塞的异步处理，同时保证主线程的高效运行</strong></p>
<p>浏览器事件循环主要分为<font style="color:#DF2A3F;">宏任务</font>和<font style="color:#DF2A3F;">微任务</font>两类队列，其中宏任务主要包括 <code>setTimeout</code>、<code>setInterval</code>、<code>DOM事件</code>、<code>AJAX回调</code>、<code>requestAnimationFrame</code>等，微任务主要包括<code>Promise.then</code>、<code>MutationObserver</code>等，浏览器事件循环特点是 <font style="color:#DF2A3F;">每次执行一个宏任务、清空微任务队列</font></p>
<font style="color:#DF2A3F;">执行顺序： 清空微任务队列 -＞ 宏任务 -> 页面渲染 -> 下一个事件循环</font>

<p><strong><font style="color:#DF2A3F;">NodeJS 事件循环的核心作用是高效处理高并发下的非阻塞操作（文件读写、网络请求）</font></strong></p>
<p>NodeJS 事件循环主要可以分为 6 个阶段，分别是<code>Timers阶段</code>这个阶段用于执行<code>setTimeout</code>和 <code>setInterval</code>的回调，<code>Pending Callbacks阶段</code> 该阶段用于处理操作系统产生的回调，后面是<code>Idle阶段</code>和 <code>Poll阶段</code>，在<code>Poll阶段</code>常用于处理网络请求和文件读写的操作回调，最后是<code>Check阶段</code>和<code>Close Callbacks阶段</code>，在<code>Check阶段</code>用来执行 <code>setImmediate回调</code>，对于<code>Close Callbacks</code>就是用于处理一些关闭的逻辑回调</p>
<p>在 <code>NodeJS</code> 事件循环中会在每个阶段结束后清空微任务队列，并且在微任务中<code>process.nextTick</code>的优先级最高，会在当前阶段结束后立即执行，而且当 <code>Poll</code> 阶段执行时，如果 <code>Poll</code> 队列不为空就执行 <code>I/O</code> 回调直到队列为空，如果 <code>Poll</code> 队列为空，就会检查是否有<code>setImmediate回调 -&gt; Check阶段</code>，检查 <code>定时器是否到期 -&gt; Timer阶段</code>，否则<font style="color:#E4495B;">阻塞等待新的 <code>I/O</code> 事件</font></p>
<p><code>Timer</code>阶段 -&gt; <code>Pending Callbacks</code> 阶段 -&gt; <code>Idle</code> 阶段 -&gt;<code>Poll</code> 阶段 -&gt; <code>Check</code> 阶段 -&gt; <code>Close callbacks</code>阶段</p>
<h4 id="宏任务和微任务之间有什么区别吗"><a href="#宏任务和微任务之间有什么区别吗" class="headerlink" title="宏任务和微任务之间有什么区别吗?"></a>宏任务和微任务之间有什么区别吗?</h4><p>宏任务由宿主环境发起，比如浏览器环境或 <code>NodeJS</code> 环境来实现宏任务的调度，常见的宏任务有<code>setTimeout</code>、<code>setInterval</code>，以及<font style="color:#DF2A3F;">文件读写、网络请求等 <code>I/O</code> 操作</font>。宏任务可能存在多个不同类型的队列，不同类型的宏任务依据不同规则被添加到相应队列，事件循环会按照队列顺序依次选取执行。在执行过程中，一个宏任务会持续执行直至结束，只有在该宏任务执行完毕后，才会去检查微任务队列。 微任务则由 <code>JavaScript</code> 引擎自身进行管理和调度，常见的微任务包括 <code>Promise.then</code>、<code>async/await</code>以及 <code>MutationObserver</code>等。与宏任务不同，微任务仅有一个统一的队列，无论其来源如何，都会被添加到这个队列中。微任务具有更高的执行优先级，当一个宏任务执行完成后，<code>JavaScript</code> 引擎会立即处理微任务队列，将队列中的所有微任务依次执行完毕，直到队列为空，才会开启下一个宏任务的执行。</p>
<h4 id="既然-JS-是单线程的是如何实现-EventLoop-的？如何进行异步化的？"><a href="#既然-JS-是单线程的是如何实现-EventLoop-的？如何进行异步化的？" class="headerlink" title="既然 JS 是单线程的是如何实现 EventLoop 的？如何进行异步化的？"></a>既然 <code>JS</code> 是单线程的是如何实现 EventLoop 的？如何进行异步化的？</h4><h4 id="JS-中类数组的定义和转换方法"><a href="#JS-中类数组的定义和转换方法" class="headerlink" title="JS 中类数组的定义和转换方法"></a><code>JS</code> 中类数组的定义和转换方法</h4><p>类数组指的是具有<code>length</code>属性和内部元素具有索引值的对象，但是它不能使用数组中原生的方法</p>
<p>常见的将类数组转换成数组的方法有</p>
<p><code>Array.form</code></p>
<p><code>Array.prorotype.slice.call</code></p>
<p><code>Array.prototype.splice.call</code></p>
<h4 id="什么是-DOM-和-BOM"><a href="#什么是-DOM-和-BOM" class="headerlink" title="什么是 DOM 和 BOM"></a>什么是 DOM 和 BOM</h4><p><code>DOM</code> 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</p>
<p><code>BOM</code> 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。<code>BOM</code> 的核心是 <code>window</code>,<code>window</code> 对象含有 <code>location</code> 对象、<code>navigator</code> 对象、<code>screen</code> 对象等子对象，并且 <code>DOM</code> 的最根本的对象 <code>document</code> 对象也是 <code>BOM</code> 的 <code>window</code> 对象的子对象。</p>
<h4 id="异步编程的实现方式"><a href="#异步编程的实现方式" class="headerlink" title="异步编程的实现方式"></a>异步编程的实现方式</h4><p><code>JS</code> 中的异步机制可以分为回调函数、<code>Promise</code>以及<code>async/await</code>函数</p>
<p>回调函数是一个作为参数传递给其他函数的函数，并在异步操作处理时被调用，多个回调函数嵌套时会导致回调函数地狱，不利于代码的可维护性。为解决回调地狱的问题，<code>ES6</code>中引入了<code>Promise</code>，使用<code>Promise</code>的方法可以将嵌套的函数作为链式调用。但是使用这种方法有可能会造成多个<code>then</code>的链式调用，可能会导致代码的语义不够明确。此外，在<code>ES7</code>中还引入了<code>async/await</code>，<code>async</code>函数返回一个<code>Promise</code>对象，函数会将等待<code>Promise</code>对象的状态变为<code>resolve</code>后再向下执行，因此可以将异步逻辑转换为同步的顺序来书写。</p>
<h4 id="setTimeout、Promise、async-await-函数之间的区别"><a href="#setTimeout、Promise、async-await-函数之间的区别" class="headerlink" title="setTimeout、Promise、async/await 函数之间的区别"></a><code>setTimeout</code>、<code>Promise</code>、<code>async/await</code> 函数之间的区别</h4><p><strong>执行时机、语法结构、错误处理、任务队列类型</strong></p>
<p><code>setTimeout</code> 属于基于回调函数的异步宏任务，会被推入浏览器的宏任务队列，等待当前调用栈和所有微任务完成后再执行，而且当多个回调函数嵌套时容易导致回调地狱和需要手动在回调函数内处理错误</p>
<p><code>Promise</code> 属于链式调用的异步微任务，会被推入浏览器的微任务队列，优先级高于宏任务在当前事件循环尾末立即执行，使用<code>.then</code> 和<code>.catch</code> 执行成功和失败的回调函数，解决了回调嵌套导致的回调地狱问题</p>
<p><code>Async/await</code> 是基于 <code>Promise</code> 的语法糖，其本质仍是微任务，使用 <code>async</code> 声明异步函数，<code>await</code> 暂停执行等待 <code>Promise</code> 结果，使得异步逻辑转换成同步的顺序来书写，使得代码可读性更强</p>
<h4 id="Promise-理解"><a href="#Promise-理解" class="headerlink" title="Promise 理解"></a><font style="color:#F1A2AB;"><code>Promise</code> 理解</font></h4><p><code>Promise</code> 是异步编程的一种解决方案，可以获取到异步操作的消息，它的出现解决了多个回调函数嵌套导致的回调地狱问题。<code>Promise</code>是一个构造函数，接收一个函数作为参数，返回一个<code>Promise</code>实例。一个<code>Promise</code>实例有三种状态，分别是<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>，分别代表进行中，已完成和已拒绝，并且实例的状态只能从<code>pending</code>转变成<code>fulfilled</code>或者<code>rejected</code>，一旦状态改变就无法修改。<code>Promise</code>实例状态改变是通过调用<code>resolve()</code>和<code>reject()</code>函数来实现的，可以通过调用原型上的<code>.then</code>和<code>.catch</code>方法来执行成功和失败后的回调函数</p>
<h4 id="Promise-的基本用法"><a href="#Promise-的基本用法" class="headerlink" title="Promise 的基本用法"></a><code>Promise</code> 的基本用法</h4><p><strong>创建 <code>Promise</code> 对象：</strong></p>
<p>使用构建函数的方式创建<code>Promise</code>对象 <code>const p = new Promise(fun)</code></p>
<p>还可以直接使用<code>Promise.resolve</code>和 <code>Promise.reject</code>来创建<code>Promise</code>对象，然后由<code>.then</code>和<code>.catch</code>来执行成功和拒绝的回调函数</p>
<p><strong><code>Promise</code> 方法：</strong></p>
<p><code>Promise</code>常用的方法有<code>then</code>、<code>catch</code>、<code>all</code>、<code>race</code>、<code>finally</code></p>
<p><code>then</code>可以接收两个回调函数作为参数，第一个回调函数是<code>Promise</code>对象状态变为<code>fulfilled</code>时调用，第二个回调函数是<code>Promise</code>对象状态变为<code>rejected</code>时调用，但一般使用<code>catch</code>执行<code>Promise</code>对象状态变为<code>rejected</code>时的回调函数，而且相对于<code>then</code>的第二个回调函数不同的是，当执行<code>resolve</code>回调函数时，如果出现错误抛出异常就会进入<code>catch</code>方法中，</p>
<p>对于<code>all</code>和<code>race</code>两个方法都是接收<code>Promise</code>数组，但是<code>all</code>只有当数组中的所有<code>promise</code>对象状态都变为<code>fulfilled</code>时才会表示执行成功，状态由<code>pending</code>变为<code>fulfilled</code>，否则就变为<code>rejected</code>，而<code>race</code>则是返回第一个执行完成的<code>Promise</code>对象，如果第一个<code>Promise</code>执行成功则自身状态变为<code>fulfilled</code>，执行失败这变为<code>rejected</code></p>
<p><code>finally</code>方法用于指定无论<code>Promise</code>对象最终状态如何都要执行的操作，<code>finally</code>中不接受任何参数，常用于执行与状态无关的、不依赖于<code>Promise</code>结果的操作</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a><code>async/await</code></h3><h4 id="谈谈-async-await-是-Promise-的语法糖"><a href="#谈谈-async-await-是-Promise-的语法糖" class="headerlink" title="谈谈 async/await 是 Promise 的语法糖"></a>谈谈 <code>async/await</code> 是 <code>Promise</code> 的语法糖</h4><p>通过生成器的<code>yield</code>暂停函数执行，由执行器等待<code>promise</code>完成，并将结果回传以恢复生成器，最终实现以同步代码风格编写异步逻辑</p>
<p><strong><code>async/await</code> 的理解</strong></p>
<p><code>async/await</code>其实是基于<code>Promise</code>的语法糖，是为优化多个<code>then</code>的链式调用开发出来的，它的特点是将异步逻辑转换成同步的顺序来书写，增加了代码的可读性。<code>async</code>函数返回的是一个<code>Promise</code>对象，所以除了使用<code>await</code>获取返回值时也可以使用<code>then</code>和<code>catch</code>来处理<code>Promise</code>对象</p>
<p><strong><code>await</code> 在等什么？</strong></p>
<p><code>await</code>等待的是<code>async</code>返回的<code>Promise</code>对象，当<code>Promise</code>在执行过程中，<code>await</code>会阻塞后面的代码直到<code>Promise</code>对象<code>resolve</code>，然后得到<code>resolve</code>的值作为<code>await</code>表达式的运算结果，但是如果返回的不是<code>Promise</code>对象，则<code>await</code>直接将返回结果作为运算结果返回</p>
<p><code>async/await</code>的优势</p>
<p>async/await 能将异步逻辑转换成同步的顺序进行书写，使代码读起来更加同步，对比 Promise 来说，Promise 虽然解决了回调地狱的问题，但是多个<code>then</code>的链式回调会导致逻辑的可读性变差，此外<code>async/await</code>可以使用<code>try/catch</code>来处理错误，但<code>Promise</code>错误捕获更加冗余</p>
<h3 id="作用域、作用域链"><a href="#作用域、作用域链" class="headerlink" title="作用域、作用域链"></a>作用域、作用域链</h3><p>作用域定义了变量和函数的可访问范围，它决定了代码中变量和函数的可见性与生命周期。根据作用域范围可分为全局作用域、函数作用域、块级作用域，其中全局作用域是最外层的作用域，在全局作用域声明的变量和函数可以在代码的任何地方访问。在浏览器环境中，全局作用域对应的对象是 <code>window</code> 对象，在 <code>Node.js</code> 环境中，全局作用域对应的对象是 <code>global</code> 对象；函数作用域是指在函数内部定义的变量和函数只能在该函数内部访问，外部无法访问。使用 <code>var</code> 关键字声明的变量具有函数作用域；块级作用域是使用 <code>let</code> 和 <code>const</code> 关键字定义的变量具有的作用域，即变量只能在定义它们的块内部访问</p>
<p>由多个作用域依次嵌套形成的链式结构称为作用域链，在访问一个变量或者函数时，<code>JS</code> 会先在当前作用域中进行查找，如果找不到就会沿着作用域链向上查找，直到找到该变量或者到达全局作用域。作用域链的作用是确保执行环境中有权访问的所有变量和函数能够按作用域层级有序访问，从而实现对外层作用域中变量和函数的访问。</p>
<h4 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h4><p>执行上下文可以理解为当前代码的执行环境，根据执行上下文范围可以分为全局执行上下文、函数执行上下文、<code>eval</code> 执行上下文。全局执行上下文是最基础的执行上下文，在代码开始执行时就会创建，整个程序中只有一个全局执行上下文。它负责管理全局变量和全局函数，在浏览器环境中全局执行上下文对应的全局对象是<code>window</code>;当调用一个函数时，就会为该函数创建一个函数执行上下文，主要负责管理函数内部的变量和函数，每个函数调用时都会有自己独立的执行上下文；<code>Eval</code> 函数在执行时会创建自己的执行上下文，但由于其存在安全风险和性能较差，所以在实际开发中很少使用</p>
<p>每个执行上下文都有变量对象，作用域链，<code>this</code> 指针三部分组成，执行上下文的生命周期包括创建阶段和执行阶段，对于创建阶段，会创建变量对象、建立作用域链和确定 <code>this</code> 指针的指向，对于执行阶段会完成对变量的分配，最后执行代码</p>
<p>执行上下文栈：</p>
<p><code>JS</code> 中会使用执行上下文栈来管理执行上下文。执行上下文栈是一个后进先出的数据结构，当代码开始执行时，会先创建全局执行上下文并将其压入栈底。每当调用一个函数时，会为该函数创建一个新的执行上下文并将其压入栈顶，函数执行完毕后，会将该执行上下文从栈顶弹出，控制权回到上一个执行上下文。</p>
<h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><p>在 <code>JS</code> 代码运行时，需要分配内存空间来存储变量和值。当变量不在参与运行时，就需要系统回收被占用的内存空间，这就是垃圾回收</p>
<p>常见的垃圾回收机制方法有标记清除法和引用计数法，对于标记清除法来说，当变量进入执行环境时，就会标记该变量“进入环境”，被标记为“进入环境”的变量无法被回收，当变量离开环境时就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放，引用计数法就是每当有<font style="color:#DF2A3F;">新的引用指向该对象</font>时，计数器加一，反之当引用被移除时，计数器减一。当计数器的值为 0 时就表示该对象不再被引用从而被垃圾回收机制回收释放，但是<font style="color:#DF2A3F;">无法处理循环引用</font>的情况导致无法回收。</p>
<h4 id="V8-的垃圾回收机制"><a href="#V8-的垃圾回收机制" class="headerlink" title="V8 的垃圾回收机制"></a>V8 的垃圾回收机制</h4><p>V8 引擎采用分代式垃圾回收机制，将内存分为新生代和老生代两部分。新生代用于存储生命周期较短的对象，老生代用于存储生命周期较长的对象。新生代采用 <code>Scavenge</code> 算法进行垃圾回收，老生代采用标记清除算法。</p>
<p>新生代算法使用的是 <code>Scavenge</code> 算法：将内存空间分为两部分，分别是<code>from</code>和<code>to</code>空间，在<code>form</code>空间被占满后就将失活的对象进行销毁，将存活的数据复制到<code>To</code>空间中，复制完成后互换<code>from</code>和<code>To</code>空间</p>
<p>导致内存泄露的情况：</p>
<p>内存泄露指的是<font style="color:#DF2A3F;">程序中已不再使用的内存未被及时释放，导致内存占用不断增加的问题</font></p>
<p>意外的全局变量：使用未声明的变量而意外创建的全局变量会导致无法被回收</p>
<p>未清除的定时器和回调函数：未及时清除的定时器以及在回调函数中引用了外部变量，也会导致内存泄露</p>
<p>闭包：不合理的使用闭包，会导致某些变量一直被留在内存中</p>
<h4 id="谈谈你对requestAnimationFrame的理解"><a href="#谈谈你对requestAnimationFrame的理解" class="headerlink" title="谈谈你对requestAnimationFrame的理解"></a>谈谈你对<code>requestAnimationFrame</code>的理解</h4><p><code>requestAnimationFrame</code>是浏览器提供的优化动画渲染的 API，<code>requestAnimationFrame</code>的回调函数会与浏览器的屏幕刷新周期同步执行以确保动画的流畅性，并且当页面切换到后台时，<code>requestAnimationFrame</code>会自动停止调用。<font style="color:#DF2A3F;">相较于普通定时器而言<code>requestAnimationFrame</code>不依赖于事件循环，与浏览器渲染周期同步，能自动合并帧内多次 DOM 操作，减少重绘重排，同时也解决了定时器函数无法准时触发导致的动画丢帧和卡顿的情况，在使用时应保证回调逻辑尽可能轻量，或转至<code>web worker</code>中进行否则可能会阻塞主线程，还有要及时清除防止内存泄露，</font>常用于复杂动画的渲染。</p>
<p>清除动画的方式：<code>cancelAnimationFrame</code></p>
<h4 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h4><p>深拷贝指的是通过递归复制对象的所有层级属性，完全创建新对象，与原对象无引用关系。浅拷贝指的是仅复制对象的第一层属性，若属性为引用类型，则复制其内存地址。两者最本质的区别是浅拷贝在修改拷贝后的引用类型属性时会修改原对象，但是深拷贝不会。</p>
<p>浅拷贝的常用方式：<font style="color:#DF2A3F;">扩展运算符、<code>Object.assign()</code></font></p>
<p>深拷贝的常用方式：<font style="color:#DF2A3F;">JSON 序列化与反序列化</font></p>
<font style="color:#DF2A3F;">使用递归实现手写深拷贝</font>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> map.<span class="title function_">get</span>(obj);</span><br><span class="line">  <span class="keyword">const</span> clone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  map.<span class="title function_">set</span>(obj, clone);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      clone[key] = <span class="title function_">deepClone</span>(obj[key], map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for in 和 for of 的区别"></a>for in 和 for of 的区别</h4><p><code>for of</code> 遍历获取的是对象的键值，<code>for in</code>获取的是对象的键名</p>
<p><code>for in</code> 会遍历对象的整个原型链，性能较差不推荐使用，而<code>for of</code>只遍历当前对象不会遍历原型链</p>
<p>对于数组的遍历，<code>for in</code>会返回数组中所有可枚举的属性，<code>for of</code> 只返回数组的下标对应的属性值</p>
<h4 id="如何使用-for-of-遍历对象"><a href="#如何使用-for-of-遍历对象" class="headerlink" title="如何使用 for of 遍历对象"></a>如何使用 for of 遍历对象</h4><p>对于类数组对象，则使用<code>Array.form</code>转换成数组即可</p>
<p>对于普通对象，需要给对象添加一个<code>[Symbol.iterator]</code>属性，并指向一个迭代器即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(count&lt;keys.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>:obj[keys[count++]]&#125;,<span class="attr">done</span>:<span class="literal">false</span>&#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何实现字符串数组的去重操作"><a href="#如何实现字符串数组的去重操作" class="headerlink" title="如何实现字符串数组的去重操作"></a>如何实现字符串数组的去重操作</h4><p><strong>对于普通数组的去重</strong></p>
<p>使用 <strong><code>Set</code></strong> 数据结构去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]; <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>使用 <strong><code>filter + indexOf</code></strong> 去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArr = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> arr.<span class="title function_">indexOf</span>(item) === index);</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>使用 <strong><code>reduce + includes</code></strong> 去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce(callback(累加器,当前数组元素item),累加器的初始值) 返回的是累加器中的值</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArr = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> acc.<span class="title function_">includes</span>(item) ? acc : [...arr, item];</span><br><span class="line">&#125;, []);</span><br><span class="line">uniqueArr; <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>对于需要去除相同大小的数组<code>[1,2,&#39;2&#39;,&#39;3&#39;,3,4,5]</code></p>
<p>使用<strong>Map 对象和类型转换</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> uniqueArr = [];</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = <span class="title class_">String</span>(item);</span><br><span class="line">  <span class="keyword">if</span> (!map.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">    map.<span class="title function_">set</span>(key, <span class="literal">true</span>);</span><br><span class="line">    uniqueArr.<span class="title function_">push</span>(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">uniqueArr; <span class="comment">// [1,2,&#x27;3&#x27;,4,5]</span></span><br></pre></td></tr></table></figure>
<h4 id="如何实现数组的复制操作（输入-1-2-3-4-输出-1-2-3-4-1-2-3-4-）"><a href="#如何实现数组的复制操作（输入-1-2-3-4-输出-1-2-3-4-1-2-3-4-）" class="headerlink" title="如何实现数组的复制操作（输入[1,2,3,4],输出[1,2,3,4,1,2,3,4]）"></a>如何实现数组的复制操作（输入[1,2,3,4],输出[1,2,3,4,1,2,3,4]）</h4><p>使用扩展运算符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> newArr = [...arr, ...arr];</span><br></pre></td></tr></table></figure>
<p>使用 concat 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> newArr = arr.<span class="title function_">concat</span>(arr);</span><br></pre></td></tr></table></figure>
<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a><font style="color:#F1A2AB;">数组方法</font></h4><ul>
<li>增 <code>push</code>(尾部添加) <code>unshift</code> 头部添加</li>
<li>删 <code>pop</code> (尾部删除) <code>shfit</code> 头部删除 <code>splice(索引值,需要删除的数量,插入的新的数组元素)</code>插入到当前元素前</li>
<li>改 <code>reverse</code> <code>sort</code></li>
<li>查 <code>foreach</code> <code>map</code> <code>filter</code> <code>reduce</code> <code>some</code> <code>every</code> <code>find</code> <code>findIndex</code> <code>indexOf</code> <code>include</code></li>
<li>合并 <code>concat</code> <code>flat</code> <code>join</code></li>
</ul>
<p><code>foreach</code>方法会针对每个元素执行提供的函数，对数据操作会改变原数组，方法没有返回值，<code>map</code>方法不会改变原数组的值，对原数组操作后会返回一个操作后的新数组</p>
<h4 id="前端常见的存储方式-浏览器本地存储方式和使用场景-cookie、LocalStorage、SessionStorage-区别"><a href="#前端常见的存储方式-浏览器本地存储方式和使用场景-cookie、LocalStorage、SessionStorage-区别" class="headerlink" title="前端常见的存储方式/浏览器本地存储方式和使用场景/cookie、LocalStorage、SessionStorage 区别"></a>前端常见的存储方式/浏览器本地存储方式和使用场景/cookie、LocalStorage、SessionStorage 区别</h4><p>浏览器中使用的存储方式主要有<code>cookie</code>、<code>localStorage</code>、<code>sessionStorage</code>和<code>IndexedDB</code>等，其中<code>cookie</code>是服务器在客户端存储的小块数据，<font style="color:#DF2A3F;">用于客户端和服务器之间传递状态信息</font>，大小限制在<code>4KB</code>左右，可以通过<code>Expires</code>设置过期时间，常见的字段有<code>name=value</code>用于设置键值对；<code>Domain</code> 用于限制 <code>Cookie</code> 可用的域名；<code>Secure</code> 仅在<code>HTTPS</code>连接传输，防止中间人攻击；<code>HttpOnly</code> 仅限 <font style="color:#DF2A3F;">服务器</font> 访问，防止<code>JavaScript</code> 读取；<code>SameSite</code> 限制跨站请求携带<code>Cookie</code>。<code>localStorage</code>和<code>sessionStorage</code>都是在<code>HTML5</code>的新特性，<code>localStorage</code> 常用于持久化的数据存储，一般大小限制为<code>5MB</code>，<font style="color:#DF2A3F;">数据持久存储，除非主动删除，并且在同源策略下所有页面共享存储的数据</font>，常用于保存用户信息，<code>sessionStorage</code>是一种临时的本地存储方式，数据在关闭页面或浏览器后失效，常用于<font style="color:#DF2A3F;">同一窗口或标签内的数据共享和存储，不能用于标签页之间的通信</font>。<code>IndexedDB</code> 是浏览器提供的<font style="color:#DF2A3F;">本地数据库</font>，一般在 50MB 左右，支持二进制存储和异步读写，常用于存储离线信息和数据同步中。</p>
<h4 id="JWT-和-session-之间有什么区别"><a href="#JWT-和-session-之间有什么区别" class="headerlink" title="JWT 和 session 之间有什么区别"></a>JWT 和 session 之间有什么区别</h4><p><code>JWT</code> ：<code>头部 - 负载 - 签名</code></p>
<p>在用户登录时，服务器会验证用户的身份信息，若验证通过，服务器根据用户的相关信息生成一个<code>JWT</code>，并返回给客户端。客户端在接收到<code>JWT</code>后，会将其存储在本地中，在后续的请求中，客户端会将<code>JWT</code>放在请求头<code>Authentication</code>中一同发送给服务器，服务器在接收到请求后，会验证<code>JWT</code>签名的有效性，签名有效就解析<code>JWT</code>中的负载信息，获取用户身份和权限信息，从而处理请求。</p>
<p><code>Session</code>是一种服务器端的会话机制，用于跟踪用户在多个页面之间的交互状态。当用户首次访问服务器时，服务器会为该用户创建唯一的<code>Session ID</code>，并将其发送给客户端，客户端在后续的请求中会携带<code>Session ID</code>，服务器根据<code>Session ID</code>来识别客户端并维护会话状态</p>
<p>特点：<code>JWT</code>通过请求头传递在跨域和前后端分离的场景下更加的简单便利，但如果<code>JWT</code>泄露，攻击者可以使用该令牌冒充用户来进行伪造请求攻击。<code>Session ID</code>通过将会话信息存储在服务器端，具有很高的安全性，即时<code>Session ID</code>泄露，攻击者也无法获取到用户信息，但是由于其存储会话信息的特点，需要开辟大量的内存信息，导致很大的性能开销问题。</p>
<h4 id="pnpm-和-npm-之间的区别"><a href="#pnpm-和-npm-之间的区别" class="headerlink" title="pnpm 和 npm 之间的区别"></a>pnpm 和 npm 之间的区别</h4><p>安装速度和空间占用不同：<code>npm</code> 在安装依赖时，会将依赖包完整的复制到项目的<code>node_modules</code>目录下，如果多个项目依赖同一个包就会导致大量的空间和内存浪费。<code>pnpm</code> 采用的是内存可寻址存储方式，在磁盘上仅保存一份依赖包的副本。不同项目引用相同依赖时，会通过<font style="color:#DF2A3F;">硬链接和符号链接</font>来共享该副本，提高安装效率</p>
<p>依赖结构不同：<code>npm</code>使用扁平结构来解决依赖冲突问题，把所有依赖尽可能地安装在顶层，但这种方式可能会导致不同版本的依赖包相互覆盖，引发幽灵依赖问题。<code>pnpm</code>使用嵌套结构，每个依赖包都有自己独立的 <code>node_modules</code> 目录，依赖关系更加清晰。同时，通过硬链接和符号链接共享依赖包，<font style="color:#DF2A3F;">避免了依赖冲突和幽灵依赖问题。</font></p>
<p><code>yarn</code>:<code>yarn</code>也采用扁平化的<code>node_modules</code>结构，通过引入全局缓存来避免重复下载相同的包，通过硬链接共享副本资源，内部提供了较为严格的依赖解析规则，但仍然可能存在某些情况下幽灵依赖的问题</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://weilaiggbond.github.io/">webbond</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://weilaiggbond.github.io/post/bec2f2e9.html">https://weilaiggbond.github.io/post/bec2f2e9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://weilaiggbond.github.io" target="_blank">webbond の 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/css/">css</a><a class="post-meta__tags" href="/tags/html/">html</a></div><div class="post-share"><div class="social-share" data-image="/img/cover-one.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/post/1fda37d8.html" title="在electron中实现持久化存储用户信息"><img class="cover" src="/img/cover-four.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">在electron中实现持久化存储用户信息</div></div></div></a><a class="pagination-related" href="/post/43b7283f.html" title="前端面经-前端vue技术栈"><img class="cover" src="/img/cover-three.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">前端面经-前端vue技术栈</div></div><div class="info-2"><div class="info-item-1">vue 中双向数据绑定的原理vue中的双向绑定主要依靠数据劫持的发布-订阅方式，通过Object.defineProperty方法劫持属性的getter和setter方法，在数据变动时发布信息给订阅者，触发相关的回调 使用observe对数据对象进行递归遍历，为其添加上 getter 和 setter 方法，当属性发生变化时就会调用 setter 方法，从而监听到数据的变化 使用complile对模板指令进行解析，将模板中的变量转换成真实的数据，然后初始化渲染页面视图，并为模板指令对应的节点绑定更新函数，添加监听数据的订阅者，当数据变化时进行视图的更新 watcher是连接observe和complie的桥梁，它的主要作用是在自身实例化时往属性dep上添加自己，可以在属性变化时接收到dep.notify()的指令执行自身的update()函数，触发compile上的回调 vue2 和 vue3 的主要区别 使用的 API 不同，vue3 中使用的组合式 API 代替了 vue2 中的选项式 API，相较于选项式 API，组合式 API...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/post/a074123a.html" title="使用echars实现数据可视化"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fb8f30df1-9d09-4dda-8d67-ac916206338e%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1750672169&t=8c9af1b39ac2e5f367f1e00110757d37" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-26</div><div class="info-item-2">使用echars实现数据可视化</div></div><div class="info-2"><div class="info-item-1">Echars实现数据可视化在搭建后台页面时，可能会遇到很多的表格，但有时表格所展现的数据并不能直观的体现出当前用户的宏观信息，所以就可以引入一个新的表格插件 ——Echars 快速上手 - Handbook - Apache ECharts 什么是Echars？Echarts是一个基于JavaScript的开源可视化库。它提供了各种图表类型（如折线图、柱状图、散点图、地图等）和交互组件（如数据区域缩放、拖拽、动态数据更新等），能够帮助使用者快速构建并展示数据可视化效果。 在上述概念中提出了数据可视化——数据可视化是指将数据以图表、图形、地图等可视化的形式展现出来，以方便用户更加直观地分析数据。 如何使用Echars？引入 echars 文件https://cdn.staticfile.org/echarts/4.7.0/echarts.js 首先先看一下使用 Echars 库创建的配置示例 1234567891011121314151617181920212223242526272829303132333435363738394041option = &#123; ...</div></div></div></a><a class="pagination-related" href="/post/b696d76.html" title="前端开发 - input 框动画效果实现"><img class="cover" src="/img/cover-four.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-30</div><div class="info-item-2">前端开发 - input 框动画效果实现</div></div><div class="info-2"><div class="info-item-1">前言 —- 期末周over终于熬过了期末周的艰难痛苦，转眼间已经将近一个月的时间没有敲代码了。一日不见，如隔三秋，在从期末周到现在的学习这段时间里，我学习了有关nodeJs和axios的知识，说的是学习了但实际上用的还是不太熟练，看来我需要努力的地方还有很多。 今天分享的是一些有关input框的两个前端动画效果 input框动画登录注册的input框动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950label &#123;  position: relative;  #userPassword&#123;    outline: none;    width: 80%;    height: 30px;    font-size: 20px;  &#125;  span &#123;    transition-duration: 0.5s;    font-size: 18px;    color: #5a5959;   ...</div></div></div></a><a class="pagination-related" href="/post/b696d11.html" title="前端工具 - AOS实现前端动画效果"><img class="cover" src="/img/cover-two.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="info-item-2">前端工具 - AOS实现前端动画效果</div></div><div class="info-2"><div class="info-item-1">前言在现代Web开发中，动画效果是提升用户体验和页面交互性的重要因素之一。而AOS（Animate On Scroll）作为一个强大的动画库，可以帮助我们轻松地实现网页元素的滚动动画效果。 什么是AOS？AOS是一个基于CSS3和JavaScript的动画库，它专注于为网页元素添加滚动动画效果。通过AOS，我们可以实现元素在进入或离开视口时的各种动态效果，比如淡入、滑动、旋转等。AOS的优点在于简单易用，无需编写复杂的动画代码，只需通过简单的配置就能实现惊艳的滚动动画效果。 使用AOS的基本步骤：引入AOS库在HTML文档的&lt;head&gt;标签内，加入以下代码引入AOS库的CSS和JavaScript文件： 12&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/aos/2.3.4/aos.css&quot;&gt;&lt;script...</div></div></div></a><a class="pagination-related" href="/post/b696d89.html" title="RuoYi框架的理解"><img class="cover" src="/img/cover-one.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="info-item-2">RuoYi框架的理解</div></div><div class="info-2"><div class="info-item-1">前言在前端开发的学习之旅中，我参与到了校企合作的项目开发中，让我有机会深入探索了RuoYi框架。RuoYi是一个基于SpringBoot后台和Vue前端技术栈的快速开发平台。集成了大量的前后端分离的开发实践，通过学习和实践RuoYi框架，我获得了丰富的经验和宝贵的技能，进一步加强了我作为前端开发者的能力。 RuoYi框架的理解学习心得深入了解RuoYi让我感受到了前后端分离架构的强大。RuoYi框架采用了Vue.js、Element UI和Vuex等前沿技术，为开发者提供了一整套的企业级前端解决方案，尤其是RuoYi的权限管理功能，通过引入JWT实现安全的用户认证和授权，让系统的安全性得到了极大的增强。 RuoYi前端的模块化结构也给我的项目组织带来了启发。每个功能模块如用户管理、系统监控等都被划分为独立的目录和组件，这样的划分确保了代码的清晰性和可维护性。在实际应用中，这种模块化的思想极大地提高了开发效率和代码复用性。Ruoyi可以通过简单的配置来定制功能，从后端的数据处理到前端的界面展示，所有的这些都可以通过配置文件来灵活控制。 深刻体会在 RuoYi框架中通过对 ...</div></div></div></a><a class="pagination-related" href="/post/b696d761.html" title="前端开发 - JavaScript 知识复习"><img class="cover" src="/img/cover-two.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-15</div><div class="info-item-2">前端开发 - JavaScript 知识复习</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/post/b696d762.html" title="前端开发 - 使用localStorage实现登录验证码效果"><img class="cover" src="/img/cover-five.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-01</div><div class="info-item-2">前端开发 - 使用localStorage实现登录验证码效果</div></div><div class="info-2"><div class="info-item-1">前言学习前端的42天 这一周的任务是完善增删改查和登陆页面，本来以为会很简单，但没想到原来有这么多需要改（只能怪自己原来写的太差），通过这一周的学习，我了解到一些关于页面制作时需要考虑的新角度——面对未知的用户要尽力将一切可能“扼杀”在摇篮之中，终于理解为什么编译应用为什么存在“傻瓜式”安装了：专门对付我这种英语不好还逞强的“无能”新手。 言归正传，在本周的学习中，我学习到了验证码的获取 验证码的获取实现效果：代码主要是实现了一个常见的 “获取验证码” 功能，用户点击按钮后会启动倒计时，在此期间按钮变为不可用状态，防止重复发送请求。当用户点击 “获取” 按钮后，按钮变为禁用状态并显示倒计时，在倒计时期间，尽管用户刷新页面也不会影响当前倒计时状态（使用 localStorage 保存时间），在倒计时结束后，按钮会恢复初始状态，可再次点击 样式代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">webbond</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://weilaiggbond.github.io/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/weilaiGGbond" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML-CSS-%E9%97%AE%E7%AD%94"><span class="toc-number">1.</span> <span class="toc-text">HTML+CSS 问答</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">HTML5 新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#src-%E5%92%8C-href-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">src 和 href 之间的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-number">4.</span> <span class="toc-text">行内元素和块级元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-vmin-%E5%92%8C-vmax"><span class="toc-number">5.</span> <span class="toc-text">谈谈 vmin 和 vmax</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#display"><span class="toc-number">6.</span> <span class="toc-text">display</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flex-%E5%92%8C-Gird-%E5%B8%83%E5%B1%80"><span class="toc-number">7.</span> <span class="toc-text">Flex 和 Gird 布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">伪类和伪元素的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA"><span class="toc-number">10.</span> <span class="toc-text">文本溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">11.</span> <span class="toc-text">水平垂直居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-BFC-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">12.</span> <span class="toc-text">谈谈你对 BFC 的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-number">13.</span> <span class="toc-text">回流和重绘</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TS"><span class="toc-number">13.1.</span> <span class="toc-text">TS</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TS-%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">TS 的工具类型有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type-%E5%92%8C-interface-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">type 和 interface 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E9%97%AE%E7%AD%94"><span class="toc-number"></span> <span class="toc-text">JS 问答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6-%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">ES6 中的新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%A2%AB%E4%BF%AE%E6%94%B9"><span class="toc-number">2.</span> <span class="toc-text">如何让引用数据类型的属性不被修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">防抖和节流的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ajax%E3%80%81Axios%E3%80%81fetch-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">Ajax、Axios、fetch 之间的联系和区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-this-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">谈谈你对 this 的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">7.</span> <span class="toc-text">原型链和继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">事件捕获和事件冒泡以及事件委托的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebScoket-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">9.</span> <span class="toc-text">WebScoket 的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebScoket-%E7%9A%84%E5%BF%83%E8%B7%B3%E7%9B%91%E6%B5%8B"><span class="toc-number">10.</span> <span class="toc-text">WebScoket 的心跳监测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">即时通信的方法以及区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C-NodeJS-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">浏览器事件循环和 NodeJS 事件循环的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97"><span class="toc-number">13.</span> <span class="toc-text">宏任务和微任务之间有什么区别吗?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A2%E7%84%B6-JS-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-EventLoop-%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">既然 JS 是单线程的是如何实现 EventLoop 的？如何进行异步化的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS-%E4%B8%AD%E7%B1%BB%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">JS 中类数组的定义和转换方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-DOM-%E5%92%8C-BOM"><span class="toc-number">16.</span> <span class="toc-text">什么是 DOM 和 BOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">17.</span> <span class="toc-text">异步编程的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setTimeout%E3%80%81Promise%E3%80%81async-await-%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">setTimeout、Promise、async&#x2F;await 函数之间的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-%E7%90%86%E8%A7%A3"><span class="toc-number">19.</span> <span class="toc-text">Promise 理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">20.</span> <span class="toc-text">Promise 的基本用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await"><span class="toc-number"></span> <span class="toc-text">async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-async-await-%E6%98%AF-Promise-%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">1.</span> <span class="toc-text">谈谈 async&#x2F;await 是 Promise 的语法糖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number"></span> <span class="toc-text">作用域、作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#V8-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">V8 的垃圾回收机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9requestAnimationFrame%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">谈谈你对requestAnimationFrame的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">for in 和 for of 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-for-of-%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">如何使用 for of 遍历对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E7%9A%84%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">如何实现字符串数组的去重操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C%EF%BC%88%E8%BE%93%E5%85%A5-1-2-3-4-%E8%BE%93%E5%87%BA-1-2-3-4-1-2-3-4-%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">如何实现数组的复制操作（输入[1,2,3,4],输出[1,2,3,4,1,2,3,4]）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">数组方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-cookie%E3%80%81LocalStorage%E3%80%81SessionStorage-%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">前端常见的存储方式&#x2F;浏览器本地存储方式和使用场景&#x2F;cookie、LocalStorage、SessionStorage 区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JWT-%E5%92%8C-session-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">JWT 和 session 之间有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pnpm-%E5%92%8C-npm-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">pnpm 和 npm 之间的区别</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/4af591e9.html" title="前端面经-前端工程化"><img src="https://images.steamusercontent.com/ugc/16058287679456526865/BC2C7A135ADBC3C56B549EB78EE3ED966CBF88CE/?imw=1920&amp;&amp;ima=fit&amp;impolicy=Letterbox&amp;imcolor=%23000000&amp;letterbox=false" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端工程化"/></a><div class="content"><a class="title" href="/post/4af591e9.html" title="前端面经-前端工程化">前端面经-前端工程化</a><time datetime="2025-04-18T12:03:53.000Z" title="发表于 2025-04-18 20:03:53">2025-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/95c2dd30.html" title="前端面经-前端计网"><img src="/img/cover-four.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端计网"/></a><div class="content"><a class="title" href="/post/95c2dd30.html" title="前端面经-前端计网">前端面经-前端计网</a><time datetime="2025-04-05T12:03:35.000Z" title="发表于 2025-04-05 20:03:35">2025-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/8370c532.html" title="前端面经-前端React技术栈"><img src="/img/cover-two.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端React技术栈"/></a><div class="content"><a class="title" href="/post/8370c532.html" title="前端面经-前端React技术栈">前端面经-前端React技术栈</a><time datetime="2025-03-27T12:03:11.000Z" title="发表于 2025-03-27 20:03:11">2025-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/43b7283f.html" title="前端面经-前端vue技术栈"><img src="/img/cover-three.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端vue技术栈"/></a><div class="content"><a class="title" href="/post/43b7283f.html" title="前端面经-前端vue技术栈">前端面经-前端vue技术栈</a><time datetime="2025-03-22T12:02:53.000Z" title="发表于 2025-03-22 20:02:53">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/bec2f2e9.html" title="前端面经-前端基础"><img src="/img/cover-one.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端基础"/></a><div class="content"><a class="title" href="/post/bec2f2e9.html" title="前端面经-前端基础">前端面经-前端基础</a><time datetime="2025-03-15T12:02:27.000Z" title="发表于 2025-03-15 20:02:27">2025-03-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">随便讲点什么</p><div class="bg-ad"><div>这里是由 weilaibond 精心搭建的 个人编程学习博客，一个专注于记录「从编程小白到独立开发者」成长轨迹的专属空间。无论你是初入代码世界的萌新，还是正在寻找技术共鸣的同行者，都能在这里找到属于自己的探索坐标。</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://github.com/weilaiGGbond/">weilaibond の github</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">胡乱导航</p><ul class="ft-links"><li><a href="https://weilaiggbond.github.io/about/">关于博主</a><a href="https://weilaiggbond.github.io/archives/">文章归档</a></li><li><a href="https://weilaiggbond.github.io/categories/">文章分类</a><a href="https://weilaiggbond.github.io/tags/">文章标签</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> webbond</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>