<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端面经-前端计网 | webbond の 博客</title><meta name="author" content="webbond"><meta name="copyright" content="webbond"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="计算机网络当浏览器中输入 Google.com 并且按下回车之后发生了什么？首先是浏览器解析 URL，浏览器解析协议、域名和资源路径，并对域名进行检测是否在HSTS列表中，在列表中就强制使用HTTPS协议。然后进行 缓存和DNS 解析  ，浏览器检测本地缓存中是否含有域名IP地址，如果有则向本地服务器查询缓存，没有则向配置的DNS服务器发送请求，DNS服务器通过多级查询获取 IP 地址。然后 建立">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面经-前端计网">
<meta property="og:url" content="https://weilaiggbond.github.io/post/95c2dd30.html">
<meta property="og:site_name" content="webbond の 博客">
<meta property="og:description" content="计算机网络当浏览器中输入 Google.com 并且按下回车之后发生了什么？首先是浏览器解析 URL，浏览器解析协议、域名和资源路径，并对域名进行检测是否在HSTS列表中，在列表中就强制使用HTTPS协议。然后进行 缓存和DNS 解析  ，浏览器检测本地缓存中是否含有域名IP地址，如果有则向本地服务器查询缓存，没有则向配置的DNS服务器发送请求，DNS服务器通过多级查询获取 IP 地址。然后 建立">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://weilaiggbond.github.io/img/cover-four.jpeg">
<meta property="article:published_time" content="2025-04-05T12:03:35.000Z">
<meta property="article:modified_time" content="2025-05-26T06:58:04.149Z">
<meta property="article:author" content="webbond">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://weilaiggbond.github.io/img/cover-four.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "前端面经-前端计网",
  "url": "https://weilaiggbond.github.io/post/95c2dd30.html",
  "image": "https://weilaiggbond.github.io/img/cover-four.jpeg",
  "datePublished": "2025-04-05T12:03:35.000Z",
  "dateModified": "2025-05-26T06:58:04.149Z",
  "author": [
    {
      "@type": "Person",
      "name": "webbond",
      "url": "https://weilaiggbond.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://weilaiggbond.github.io/post/95c2dd30.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面经-前端计网',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-color: rgb(247, 249, 254);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover-four.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avatar.jpg" alt="Logo"><span class="site-name">webbond の 博客</span></a><a class="nav-page-title" href="/"><span class="site-name">前端面经-前端计网</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">前端面经-前端计网</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-05T12:03:35.000Z" title="发表于 2025-04-05 20:03:35">2025-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-26T06:58:04.149Z" title="更新于 2025-05-26 14:58:04">2025-05-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="当浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#当浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="当浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>当浏览器中输入 Google.com 并且按下回车之后发生了什么？</h4><p>首先是<strong>浏览器解析</strong> <strong><code>URL</code></strong>，浏览器解析协议、域名和资源路径，并对域名进行检测是否在<code>HSTS</code>列表中，在列表中就强制使用<code>HTTPS</code>协议。然后进行 <strong>缓存和</strong><code>DNS</code><strong> 解析 </strong> ，浏览器检测本地缓存中是否含有域名<code>IP</code>地址，如果有则向本地服务器查询缓存，没有则向配置的<code>DNS</code>服务器发送请求，<code>DNS</code>服务器通过多级查询获取 IP 地址。然后 <strong>建立网络连接</strong>，可以分为<strong><code>ARP</code>解析</strong>，在局域网内，操作系统可能需要通过<code>ARP</code>确定网关或目标主机的<code>MAC</code>地址，进行 <strong><code>TCP</code> 三次握手</strong>，先有客户端发送带<code>SYN</code>标志的<code>TCP</code>包，服务器响应一个<code>SYN+ACK</code>包确认，客户端发送<code>ACK</code>包确认，从而建立可靠连接，对于使用<code>HTTPS</code>协议的网址还需要进行<strong><code>TLS</code> 握手</strong>，即客户端和服务器协商加密算法，交换证书，生成对称加密密钥，确保后续通信安全。当页面请求发送到服务器端后，服务器端会返回一个和<code>HTML</code>文件作为响应，浏览器接收响应后，浏览器会根据<code>HTML</code>生成<code>DOM</code>树，根据解析到的<code>CSS</code>文件构建<code>CSSOM</code>树，然后合并成渲染树。然后进行布局和绘制，最终将页面显示给用户，当遇到<code>script</code>标签时，判断是否含有<code>defer</code>或者<code>async</code>属性，判断是否需要异步加载脚本文件。最后当所有数据传输完成后，<code>TCP</code>连接通过<strong>四次挥手</strong>过程关闭连接</p>
<h4 id="为什么-TCP-需要进行三次握手，而不是两次？"><a href="#为什么-TCP-需要进行三次握手，而不是两次？" class="headerlink" title="为什么 TCP 需要进行三次握手，而不是两次？"></a>为什么 <strong><code>TCP</code></strong> 需要进行三次握手，而不是两次？</h4><p>如果只有两次握手，服务器端无法确定客户端是否收到自己的 <code>SYN-ACK</code>，可能会导致历史连接激活和序列号不同，而且通过三次握手能确保双向通信通道的可靠建立，避免资源浪费和数据混乱。</p>
<h4 id="DNS-协议是什么？"><a href="#DNS-协议是什么？" class="headerlink" title="DNS 协议是什么？"></a><code>DNS</code> 协议是什么？</h4><p><code>DNS</code>指的是域名系统，它提供了一种主机名到<code>IP</code>地址的转换服务，主要作用是将域名解析为<code>IP</code>地址，客户端向<code>DNS</code>服务器发送域名查询请求，<code>DNS</code>服务器会告知客户机<code>web</code>服务器的<code>IP</code>地址</p>
<h4 id="DNS的查询过程"><a href="#DNS的查询过程" class="headerlink" title="DNS的查询过程"></a><code>DNS</code>的查询过程</h4><p>首先会在浏览器缓存中查找对应的<code>IP</code>地址，如果没有则发送请求给本地<code>DNS</code>服务器，在本地域名服务器缓存中查询，如果没有则向根域名服务器发送请求，根域名服务器会返回一个查询域的顶级域名服务器地址，本地<code>DNS</code>服务器向顶级域名服务器发送请求，服务器查询自己的缓存，没有返回权威域名服务器，向权威域名服务器发送请求，域名服务器返回对应的结果，本地<code>DNS</code>服务器将返回结果保存在缓存中便于下次使用，最后将返回结果返回给浏览器</p>
<h4 id="谈谈你对HTTPS的理解"><a href="#谈谈你对HTTPS的理解" class="headerlink" title="谈谈你对HTTPS的理解"></a>谈谈你对<code>HTTPS</code>的理解</h4><p><code>HTTPS</code>是超文本传输安全协议，<code>HTTPS</code>经由<code>HTTP</code>进行通信，利用<code>SSL/TLS</code>来加密数据包来提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p><code>SSL/TLS</code>通过<strong>散列函数</strong> <strong><code>hash</code></strong> 、<strong>对称加密</strong>、<strong>非对称加密 </strong>加密算法，实现身份的验证并协商对称加密使用的密钥</p>
<h4 id="SSL-TLS-握手的过程"><a href="#SSL-TLS-握手的过程" class="headerlink" title="SSL/TLS 握手的过程"></a><strong><code>SSL/TLS</code></strong> 握手的过程</h4><p><strong>客户端问候</strong>：客户端发送包含支持的<font style="color:#DF2A3F;">协议版本号、随机数、支持的加密方式</font>等信息发送给服务器</p>
<p><strong>服务器问候</strong>：服务器回应选择的<font style="color:#DF2A3F;">协议版本号、随机数、选定的加密方式以及数字证书</font>等信息给客户端</p>
<p><strong>证书验证</strong>：客户端<font style="color:#DF2A3F;">验证证书</font>是否由受信任的<code>CA</code>签发，证书是否过期或被吊销，域名是否匹配</p>
<p><strong>密钥交换</strong>：服务器发送服务器密钥交换消息，包含密钥交换参数。客户端根据服务器证书中的公钥生成预主密钥，用服务器公钥加密后发送给服务器，该过程使用的是<font style="color:#DF2A3F;">非对称加密进行协商</font></p>
<p><strong>生成会话密钥</strong>：双方基于客户端随机数、服务器随机数、预主密钥生成相同的主密钥，派生<font style="color:#DF2A3F;">对称密钥</font></p>
<p><strong>握手完成</strong>：双方更换密码规范，根据协商好的加密算法和密钥进行加密通信，最后服务器发送包含先前握手消息摘要供客户端验证。</p>
<p><strong><font style="color:#DF2A3F;">加密时机</font></strong></p>
<p><strong>非对称加密的时机</strong>：非对称加密主要用于 握手阶段 的身份验证和密钥交换，即当服务器向客户端发送数字证书时以防止中间人攻击</p>
<p><strong>对称加密的时机</strong>：对称加密用于数据传输阶段，加密实际的应用数据，是在 SSL/TLS 握手完成后使用对称加密进行通信</p>
<p><strong><font style="color:#DF2A3F;">为什么使用非对称加密</font></strong></p>
<p>非对称加密的使用是为了解决传统对称加密的密钥分发问题，对称加密如果密钥被截获会导致通信泄露，增加中间人捕获的风险</p>
<h4 id="TCP和UDP的概念和特点以及区别"><a href="#TCP和UDP的概念和特点以及区别" class="headerlink" title="TCP和UDP的概念和特点以及区别"></a><code>TCP</code>和<code>UDP</code>的概念和特点以及区别</h4><p><code>TCP</code>指的是传输控制协议，其特点是面向连接和使用可靠传输保证数据顺序和正确性，而且使用拥塞控制算法动态调整发送速率避免网络拥塞,但是由于其流式传输的特点可能会导致粘包。常用于文件传输、网页浏览等</p>
<p><code>UDP</code>指的是用户数据报协议，其特点是无连接，直接发送数据报，具有消息边界，每个数据报独立，无粘包问题，低延迟，但是由于属于不可靠传输，可能导致丢包和乱序。常用于实时视频流，<code>DNS</code>查询等</p>
<h4 id="TCP的三次握手、四次挥手"><a href="#TCP的三次握手、四次挥手" class="headerlink" title="TCP的三次握手、四次挥手"></a><code>TCP</code>的三次握手、四次挥手</h4><p><code>TCP</code>的三次握手指的是客户端和服务器之间建立<code>TCP</code>连接的过程，<strong>可以分为客户端发送 SYN 报文给服务端</strong>、<strong>服务端接收 <code>SYN</code> 并返回<code>SYN-ACK</code>给客户端</strong>、<strong>客户端确认信息返回 ACK 给客户端实现通信</strong>三个过程</p>
<p><strong>为什么必须是三次？</strong></p>
<p>可以避免生效的<code>SYN</code>请求到达服务器导致资源浪费</p>
<p><code>TCP</code>四次挥手指的是客户端与服务器之间断开<code>TCP</code>连接的过程，客户端主动向服务器发送<code>FIN</code>包请求断开连接，服务端回复<code>ACK</code>确认收到信息，服务端在处理完数据后发送<code>FIN</code>包给客户端，客户端回复<code>ACK</code>确认关闭信息</p>
<h4 id="SYN-泛洪攻击"><a href="#SYN-泛洪攻击" class="headerlink" title="SYN 泛洪攻击"></a><code>SYN</code> 泛洪攻击</h4><p>利用<code>TCP</code>三次握手的特性，攻击者发送携带<code>SYN</code>标志的<code>TCP</code>包发送给服务器，当服务器返回<code>SYN-ACK</code>确认包后，攻击者不对确认包进行确认，导致<code>TCP</code>连接一直处于挂起的状态，也就是半连接状态，在服务器收不到确认响应后，仍然会重新发送<code>ACK</code>给攻击者，导致服务器资源浪费，甚至死机</p>
<h4 id="对浏览器缓存机制的理解"><a href="#对浏览器缓存机制的理解" class="headerlink" title="对浏览器缓存机制的理解"></a>对浏览器缓存机制的理解</h4><p><strong>浏览器缓存的过程</strong></p>
<p>在首次请求资源时，浏览器会从服务器下载资源文件并存储资源文件和请求头，以便下次使用，当再次请求支援时，浏览器先检查之前的缓存是否有效，如果未过期这进行强缓存，直接返回本地资源，不发送请求，如果已过期则进行协商缓存，浏览器携带缓存标识（<code>Etag</code>（资源唯一标识）或<code>Last-Modified</code>（资源最后修改时间））向服务器发送请求,服务器对请求进行验证，如果资源未更改返回<code>304</code>，浏览器继续使用本地资源，如果资源修改并返回<code>200</code>和新资源，浏览器更新缓存。用户还可以使用<code>Ctrl+F5</code>强制刷新跳过所有资源，重新从服务器中获取资源。</p>
<h4 id="强缓存、协商缓存、离线缓存的理解和区别"><a href="#强缓存、协商缓存、离线缓存的理解和区别" class="headerlink" title="强缓存、协商缓存、离线缓存的理解和区别"></a><font style="color:#DF2A3F;">强缓存、协商缓存、离线缓存的理解和区别</font></h4><p>强缓存策略是直接使用本地资源，不向服务器发送请求，可以使用请求头信息中的<code>Expires</code>属性和<code>Cache-Control</code>属性来控制，服务器通过在响应头中添加<code>Expires</code>属性来指定资源过期时间。在过期时间内，该资源可以被缓存使用，不必再向服务器发送请求，但是该时间可能会被客户端时间影响所以在<code>HTTP1.1</code>中引入了<code>Cache-Control</code>属性，提供对资源缓存更精准的控制，其中关键的字段有<code>max-age</code>来规定缓存的有效期，<code>no-cache</code>用来跳过强缓存，直接进入协商缓存，还以<code>no-store</code>来完全禁用缓存，资源直接从服务器获取。</p>
<p>协商缓存策略是向服务器验证缓存是否有效，有效则继续使用本地资源，否则根据新资源更新缓存，在强缓存过期后，浏览器携带<code>Etag</code>（资源唯一标识）或<code>Last-Modified</code>（资源最后修改时间）向服务器发送请求，服务器对比资源标识<code>Etag</code>判断资源是否修改，如果资源未更改返回<code>304</code>，浏览器继续使用本地资源，如果资源修改并返回 200 和新资源，浏览器更新缓存。</p>
<p>离线缓存指的是通过<code>Service Worker</code>拦截网络请求，利用<code>Cache API</code>完全控制缓存逻辑，可以在无网络时加载已缓存的资源，或者预缓存关键资源、动态缓存请求结果，而且<code>Service Worker</code>是一种运行在浏览器后台的独立脚本，不影响主线程的性能，但是由于其中涉及到请求拦截，所以必须使用<code>HTTPS</code>协议保证安全。</p>
<h4 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a><font style="color:#DF2A3F;">浏览器同源策略</font></h4><p>跨域问题是由于浏览器的同源策略导致的，即协议、域名、端口三者必须保持一致。</p>
<p>同源策略的目的主要是为了保证用户的信息安全，用于限制从同源加载的文档或者脚本如何与另一个源的资源进行交互</p>
<h4 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h4><p><code>CORS</code>: <font style="color:#DF2A3F;">通过设置响应头，明确允许访问资源</font></p>
<p><code>JSONP</code> <font style="color:#DF2A3F;">: 通过</font><code>script</code><font style="color:#DF2A3F;">标签发送跨域请求，避开同源策略的限制</font></p>
<p><code>postMessage</code><font style="color:#DF2A3F;">: 通过指定目标源和验证来源信息实现跨域通信</font></p>
<p><code>nginx代理跨域</code><font style="color:#DF2A3F;"> ：通过启动一个代理服务器，实现数据的转发</font></p>
<p><code>nodejs 中间件代理跨域</code><font style="color:#DF2A3F;">：通过启动一个代理服务器，实现数据的转发</font></p>
<p><code>WebSocket 协议跨域</code><font style="color:#DF2A3F;">：</font><code>WebSocket</code><font style="color:#DF2A3F;"> 实现了浏览器与服务器全双工通信，同时允许跨域通信</font></p>
<h4 id="浏览器多个标签通信"><a href="#浏览器多个标签通信" class="headerlink" title="浏览器多个标签通信"></a>浏览器多个标签通信</h4><p>使用<code>webscoket</code>协议：利用服务器广播消息到所有连接的客户端</p>
<p>使用 <code>ShareWorker</code> 的方法：通过共享的<code>web Worker</code>作为中间代理，实现标签页间通信</p>
<p>使用 <code>localStorage</code> 的方式：利用<code>localStorage</code>的跨标签存储特性，实现同源标签页的通信</p>
<p>使用 <code>postMessage</code> 方法：通过 <code>window.open</code> 获取其他标签页的窗口引用，直接发送消息，子标签通过监听 <code>message</code> 事件获取数据</p>
<h4 id="HTTP1-0、HTTP1-1、HTTP2-0、HTTP3-0之间的区别和理解"><a href="#HTTP1-0、HTTP1-1、HTTP2-0、HTTP3-0之间的区别和理解" class="headerlink" title="HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0之间的区别和理解"></a><code>HTTP1.0</code>、<code>HTTP1.1</code>、<code>HTTP2.0</code>、<code>HTTP3.0</code>之间的区别和理解</h4><p>对于<code>HTTP/1.0</code>来说，它使用的是短连接和无状态连接，会导致频繁的<code>TCP</code>握手导致性能瓶颈，<code>HTTP1.1</code>基于<code>HTTP1.0</code>进行了改进，建立了持久化的长连接，默认使用<code>Connection:keep-alive</code>实现多个请求可共享一个 TCP 连接，和管道化允许发送多个请求，此外还引入<code>ETag</code>和<code>Cache-Control</code>等进行缓存优化，但是仍然存在对头阻塞（请求必须按顺序返回，前一个请求慢会阻塞后续请求）和多个请求需要多个 TCP 连接实现的问题。而<code>HTTP2.0</code>使用多路复用（一个<code>TCP</code>连接上可并发多个请求，互不影响）解决了<code>HTTP1.1</code>中出现的队头阻塞，而且<code>HTTP2.0</code>中还使用头部压缩和服务器推送来减少冗余头部大小和客户端请求延迟，但是由于<code>HTTP2.0</code>仍然基于<code>TCP</code>协议会导致如果出现丢包问题，整个<code>TCP</code>连接上的所有请求都会受影响。</p>
<p><code>HTTP3.0</code>是基于<code>UDP</code>开发的<code>QUIC</code>协议，<code>QUIC</code>在<code>UDP</code>的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些<code>TCP</code>中的特性，同时还使用独立流的多路复用来解决传输层队头阻塞问题。又由于基于<code>UDP</code>，可以实现使用<code>0 ~ 1</code>个<code>RTT</code>来建立连接，同时<code>QUIC</code>集成了<code>TLS1.3</code>加密功能，减少了握手所花费的<code>RTT</code>数。</p>
<h4 id="HTTP协议和HTTPS协议的区别"><a href="#HTTP协议和HTTPS协议的区别" class="headerlink" title="HTTP协议和HTTPS协议的区别"></a><code>HTTP</code>协议和<code>HTTPS</code>协议的区别</h4><p><strong>安全性不同：</strong><code>HTTP</code>协议是超文本传输协议，信息是明文传输的，<code>HTTPS</code>协议是超文本传输安全协议，具有安全性的<code>SSL</code>加密传输和身份认证的安全协议，比<code>HTTP</code>协议更加安全</p>
<p><strong>费用不同：</strong><code>HTTPS</code>协议需要<code>CA</code>证书，费用较高；而<code>HTTP</code>协议不需要</p>
<p><strong>连接和端口不同</strong>：HTTP 协议是无状态连接，并且默认端口是<code>80</code>，HTTPS 协议端口是<code>443</code></p>
<h5 id="IPV4和IPV6的区别"><a href="#IPV4和IPV6的区别" class="headerlink" title="IPV4和IPV6的区别"></a><code>IPV4</code>和<code>IPV6</code>的区别</h5><p>地址空间上，<code>IPv4</code> 是 32 位二进制，<code>IPv6</code> 为 128 位二进制，地址近乎无穷，解决了 <code>IPv4</code> 地址数量较少的问题；地址表示上，<code>IPv4</code> 是点分十进制，<code>IPv6</code> 采用冒号十六进制；报头格式里，<code>IPv6</code> 将 <code>IPv4</code> 中的可选字段移至扩展首部，提高了路由器处理数据包效率；安全性上，<code>IPv6</code> 内置了 <code>IPsec</code>提供了端到端的安全通信，<code>IPv4</code> 需额外机制。</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><code>HTTP</code>协议</h3><h4 id="GET和POST请求的区别"><a href="#GET和POST请求的区别" class="headerlink" title="GET和POST请求的区别"></a><code>GET</code>和<code>POST</code>请求的区别</h4><p><strong>应用场景不同：</strong><code>GET</code>请求一般用于获取服务器资源，并且不会对服务器资源产生影响的场景；<code>POST</code>请求一般用于提交实体信息或者对服务器资源产生影响的场景，而且浏览器一般会对<code>GET</code>请求进行缓存，但很少对<code>POST</code>请求进行缓存</p>
<p><strong>安全性不同：</strong><code>GET</code>请求一般会将参数放入<code>url</code>中向服务端发送，与<code>POST</code>请求相比安全性较差</p>
<p><strong>请求长度限制：</strong>由于浏览器对<code>url</code>长度的限制，所以可能会影响<code>GET</code>请求发送数据的长度</p>
<h4 id="常见的-HTTP-响应头和请求头"><a href="#常见的-HTTP-响应头和请求头" class="headerlink" title="常见的 HTTP 响应头和请求头"></a>常见的 <code>HTTP</code> 响应头和请求头</h4><p>常见的 <code>Content-Type</code> 属性值有以下四种：</p>
<ul>
<li><p><code>application/x-www-form-urlencoded</code>：浏览器的原生 <code>form</code> 表单，如果不设置 <code>enctype</code> 属性，那么最终就会以 <code>application/x-www-form-urlencoded</code> 方式提交数据。该种方式提交的数据放在 <code>body</code> 里面，数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，key 和 val 都进行了 URL 转码。</p>
</li>
<li><p><code>multipart/form-data</code>：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p>
</li>
<li><p><code>application/json</code>：服务器消息主体是序列化后的 JSON 字符串。</p>
</li>
<li><p><code>text/xml</code>：该种方式主要用来提交 <code>XML</code> 格式的数据。</p>
</li>
</ul>
<p>常见的请求头</p>
<p><strong><code>Host：</code></strong>用于指定服务器的域名和端口号</p>
<p><strong><code>User-Agent：</code></strong>浏览器的用户代理字符串</p>
<p><strong><code>Accept：</code></strong>声明客户端可接受的响应内容类型</p>
<p><strong><code>Accept-Language：</code></strong>客户端支持的语言类型</p>
<p><strong><code>Accept-Encoding:</code></strong>客户端支持的压缩算法</p>
<p><strong><code>Authorization：</code></strong>携带身份验证信息</p>
<p><strong><code>Connection：</code></strong>管理连接是否保持活动</p>
<p><strong><code>Cookie：</code></strong>发送服务器设置的<code>Cookie</code></p>
<p><strong><code>Cache-Control：</code></strong>控制缓存行为</p>
<p>常见的响应头</p>
<p><strong><code>Date：</code></strong>响应生成的时间</p>
<p><strong><code>server：</code></strong>服务器软件信息</p>
<p><strong><code>Cache-Control：</code></strong>控制 HTTP 缓存</p>
<p><strong><code>Content-Type：</code></strong> 响应体的媒体类型</p>
<h4 id="HTTP状态码304是多好还是少好"><a href="#HTTP状态码304是多好还是少好" class="headerlink" title="HTTP状态码304是多好还是少好"></a><code>HTTP</code>状态码<code>304</code>是多好还是少好</h4><p><code>HTTP</code>状态码<code>304</code>更少较好，状态码<code>304</code>不是错误，而是浏览器对于<font style="color:#01B2BC;">客户端有缓存情况</font>下的一种响应，导致<code>304</code>状态码的原因主要是<font style="color:#01B2BC;">页面更新周期太长或者不更新</font>，可能会导致<font style="color:#01B2BC;">搜索引擎对页面抓取次数减少，降低被搜索到的权重</font></p>
<h4 id="常见的-HTTP-请求方法"><a href="#常见的-HTTP-请求方法" class="headerlink" title="常见的 HTTP 请求方法"></a>常见的 HTTP 请求方法</h4><p><code>GET</code><font style="color:#DF2A3F;">用于获取服务器资源</font></p>
<p><code>POST</code><font style="color:#DF2A3F;">用于创建服务器资源</font></p>
<p><code>PUT</code><font style="color:#DF2A3F;">用于更新服务器资源</font></p>
<p><code>DELETE</code><font style="color:#DF2A3F;">用于删除服务器资源</font></p>
<p><code>OPTIONS</code><font style="color:#DF2A3F;">是在当前跨域请求不符合“简单请求”标准时，浏览器会先发送<code>OPTIONS</code>请求，确认服务器是否允许该请求，客户端可以通过<code>OPTIONS</code>请求获取服务器对某个资源支持的 <code>HTTP</code> 方法</font></p>
<p><code>HEAD</code>获取报文首部</p>
<p><code>CONNECT</code>要求在与代理服务器通信时建立隧道，使用隧道进行 <code>TCP</code> 通信</p>
<p><code>TRACE</code>回显服务器收到的请求，主要用于测试</p>
<h4 id="HTTP-协议的优缺点"><a href="#HTTP-协议的优缺点" class="headerlink" title="HTTP 协议的优缺点"></a><code>HTTP</code> 协议的优缺点</h4><p><code>HTTP</code> 是超文本传输协议，定义了客户端和服务器之间交换报文的格式和方式，具有简单快速，无连接和无状态的优点，但这也意味着 <code>HTTP</code> 无法保存客户的信息，缺少信息时就需要进行重传，而且 <code>HTTP</code> 协议还是明文传输不能保证通信的安全性</p>
<h4 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a><code>OSI</code> 七层模型</h4><p><img src="https://cdn.nlark.com/yuque/0/2025/webp/47686439/1741399997458-ca6133cb-7390-4c58-9cf8-1d91b8768242.webp" alt=""></p>
<h4 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a><code>TCP/IP</code> 五层模型</h4><p><img src="https://cdn.nlark.com/yuque/0/2025/webp/47686439/1741400019511-f4ed80e0-9a3a-4fc5-a81a-4956da671344.webp" alt=""></p>
<h4 id="TCP-的拥塞控制和流量控制算法"><a href="#TCP-的拥塞控制和流量控制算法" class="headerlink" title="TCP 的拥塞控制和流量控制算法"></a><code>TCP</code> 的拥塞控制和流量控制算法</h4><p>对于<code>TCP</code>的拥塞控制来说，其目的是防止网络过载而拥塞，通过动态调整发送速率适应网络状态，<code>TCP</code> 的拥塞控制主要是通过<font style="color:#DF2A3F;">慢启动</font>、<font style="color:#DF2A3F;">拥塞避免</font>、<font style="color:#DF2A3F;">快重传</font>、<font style="color:#DF2A3F;">快恢复</font>机制。主要过程是发送方从较小的拥塞窗口开始，每收到一个<code>ACK</code>，拥塞窗口大小的指数增长，当拥塞窗口达到慢启动阈值时，进入拥塞避免阶段，在该阶段每接收一个<code>ACK</code>，拥塞窗口线性增长，当检测到丢包时将阈值设置为当前拥塞窗口大小的一半，然后再次进入慢启动阶段。当收到 3 个重复<code>ACK</code>时表明报文段丢失，但后续报文可能已到达立刻重传丢失的报文段，无需等待超时，而后进入快恢复阶段，将阈值设置为当前拥塞窗口的一半，并且将拥塞窗口设置为阈值+3</p>
<h4 id="TCP-的重传机制"><a href="#TCP-的重传机制" class="headerlink" title="TCP 的重传机制"></a>TCP 的重传机制</h4><p><code>TCP</code>网络层可能出现丢失、重复或失序的情况，TCP 协议提供可靠的数据传输服务。为保证数据传输的正确性，<code>TCP</code>会重传其认为已丢失的包。<code>TCP</code>在发送一个数据之后，就会开启定时器，如果在时间内未收到<code>ACK</code>确认报文响应，就会对该报文进行重传，在一定次数仍未成功放弃重传发送复位信号。</p>
<h4 id="TCP-粘包处理"><a href="#TCP-粘包处理" class="headerlink" title="TCP 粘包处理"></a>TCP 粘包处理</h4><p>原因：发送方使用<code>Nagle</code>算法合并小数据包，在数据发送前缓存他们，当接收方未及时读取数据，就可能导致多个包在缓冲区堆积后被一次性读取</p>
<p>常用的解决方案：</p>
<p>多次发送之前等待时间间隔</p>
<p>关闭<code>Nagle</code>算法</p>
<p>进行封包/拆包</p>
<p><code>UDP</code><font style="color:#DF2A3F;">不会出现粘包的原因</font></p>
<p><code>UDP</code>是面向消息的协议，<code>UDP</code>段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据。此外<code>UDP</code>具有保护消息边界，在每个<code>UDP</code>包中就有消息头便于接收端区分，传输协议把数据作为独立消息传输，接收端只能接收独立数据</p>
<h4 id="TLS1-3相较于1-2的区别在哪"><a href="#TLS1-3相较于1-2的区别在哪" class="headerlink" title="TLS1.3相较于1.2的区别在哪"></a><code>TLS1.3</code>相较于<code>1.2</code>的区别在哪</h4><p>安全性:握手过程加密</p>
<ul>
<li><code>TLS 1.2</code>：握手过程中的部分消息是明文传输的，例如客户端和服务器交换的随机数、证书等信息，攻击者可以截获这些信息，有可能进行中间人攻击或分析密钥交换过程。</li>
<li><code>TLS 1.3</code>：握手过程中的关键信息都进行了加密处理，包括密钥交换参数，使得攻击者难以获取和篡改这些信息，进一步增强了握手过程的安全性。</li>
</ul>
<p>性能:握手往返次数减少</p>
<ul>
<li><code>TLS 1.2</code>：典型的握手过程需要两次往返（<code>RTT</code>），客户端和服务器之间需要多次交换消息来完成密钥交换、身份验证等步骤，在高延迟网络环境下会显著增加连接建立的时间。</li>
<li><code>TLS 1.3</code>：优化了握手流程，在理想情况下可以在一次往返中完成握手。同时还支持 <code>0 RTT</code>（零往返时间）数据传输，允许客户端在首次连接时就发送应用数据，无需等待完整的握手完成，大大提高了连接建立的速度。</li>
</ul>
<h4 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h4><h3 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h3><h4 id="谈谈你对-XSS-攻击的理解"><a href="#谈谈你对-XSS-攻击的理解" class="headerlink" title="谈谈你对 XSS 攻击的理解"></a>谈谈你对 <code>XSS</code> 攻击的理解</h4><p><code>XSS</code> 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息<br><code>XSS</code> 可以分为存储型、发射型和 <code>DOM</code> 型</p>
<p>存储型指的是将恶意脚本存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行</p>
<p>反射型指的是攻击者诱导用户访问一个带有恶意代码的 <code>URL</code> 后，服务器端接收数据处理将恶意代码发送给浏览器，浏览器解析并将其作为脚本执行，造成 <code>XSS</code> 攻击</p>
<p><code>DOM</code> 型指的通过修改页面的 <code>DOM</code> 节点形成的 <code>XSS</code>，即用户插入脚本标签更改页面内容。</p>
<p>如何防御 <code>XSS</code> 攻击</p>
<p>对 <code>HTML</code> 中的标签进行过滤，将带有恶意 <code>XSS</code> 攻击的标签不进行转义或者将其隐藏，不使用服务端渲染减少存储型攻击</p>
<p>使用 <code>CSP</code>，建立一个白名单，过滤名单外的外部资源，从而防止恶意代码的注入攻击</p>
<h4 id="谈谈-CSRF-攻击的理解"><a href="#谈谈-CSRF-攻击的理解" class="headerlink" title="谈谈 CSRF 攻击的理解"></a>谈谈 <code>CSRF</code> 攻击的理解</h4><p><code>CSRF</code> 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向攻击网站发送跨站请求，如果用户在被攻击网站中保存了登录状态，攻击者会利用当前的登录状态，冒充用户向服务器执行一些操作</p>
<p><code>CSRF</code> 攻击的本质是利用 <code>cookie</code> 会在同源请求中携带发送给服务器的特点，从此来实现用户的冒充</p>
<p><code>CSRF</code> 常见的攻击类型可分为 <code>GET</code> 类型、<code>POST</code> 类型、链接类型，当用户进入页面时或者点击时触发请求和提交</p>
<p>如何防御 <code>CSRF</code> 攻击？</p>
<p>进行同源检测，使用 <code>CSRF Token</code> 进行验证或者 <code>Cookie</code> 进行双重验证</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="谈谈对进程和线程的理解"><a href="#谈谈对进程和线程的理解" class="headerlink" title="谈谈对进程和线程的理解"></a>谈谈对进程和线程的理解</h4><font style="color:#DF2A3F;">进程是资源分配的最小单位，线程是 CPU 调度的最小单位</font>

<p>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有效的硬件资源之间的矛盾的。</p>
<p><strong>进程和线程之间的关系</strong></p>
<ul>
<li>进程中的任意一线程执行出错，都会导致整个进程的崩溃</li>
<li>线程之间共享进程中的数据</li>
<li>当一个进程关闭之后，操作系统会回收进程所占用的内存</li>
<li>进程之间的内容相互隔离</li>
</ul>
<p><strong><font style="color:#DF2A3F;">进程和线程的区别</font></strong></p>
<ul>
<li>进程可以看做独立应用，线程不能</li>
<li>进程是 <code>CPU</code> 资源分配的最小单位；线程是 <code>CPU</code> 调度的最小单位，线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程</li>
<li>线程间可以通过直接共享同一进程中的资源，而进程通信需要借助进程间通信</li>
<li>进程切换比线程切换的开销大。线程是 <code>CPU</code> 调度的最小单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换</li>
<li>由于创建或撤销进程时，系统都要为之分配或回收资源，所以进程的开销远大于创建或撤销线程时的开销。</li>
</ul>
<h4 id="线程和进程之间分别是如何通信的？"><a href="#线程和进程之间分别是如何通信的？" class="headerlink" title="线程和进程之间分别是如何通信的？"></a>线程和进程之间分别是如何通信的？</h4><p>线程间通信</p>
<ul>
<li><strong>共享内存</strong>：同一进程中的多个线程共享进程的地址空间，因此可以直接访问进程中的全局变量、堆内存等共享资源。通过对这些共享资源的读写操作，线程之间可以进行数据交换和同步。例如，一个线程修改了某个全局变量的值，其他线程可以立即看到这个变化。</li>
<li><strong>信号量</strong>：信号量是一种用于控制多个线程对共享资源访问的机制。它本质上是一个计数器，用于表示可用资源的数量。线程在访问共享资源之前，需要先获取信号量，如果信号量的值大于 0，则可以获取成功并访问资源，同时将信号量的值减 1；如果信号量的值为 0，则线程需要等待，直到其他线程释放信号量。通过信号量，线程之间可以协调对共享资源的访问，避免资源冲突。</li>
<li><strong>互斥锁</strong>：互斥锁用于确保在同一时刻只有一个线程能够访问共享资源。当一个线程获取到互斥锁后，其他线程就无法再获取该锁，直到持有锁的线程释放它。互斥锁通常用于保护临界区，即那些不允许被多个线程同时访问的代码段。例如，在对一个共享链表进行插入或删除操作时，需要使用互斥锁来保证操作的原子性和一致性。</li>
<li><strong>条件变量</strong>：条件变量通常与互斥锁一起使用，用于在线程之间进行同步。它允许线程在某个条件满足时等待，直到其他线程通知它条件已经满足。例如，一个线程需要等待某个任务完成后才能继续执行，它可以在条件变量上等待，而其他线程在完成任务后通过通知条件变量来唤醒等待的线程。</li>
</ul>
<p>进程间通信</p>
<ul>
<li><strong>管道</strong>：管道是一种半双工的通信方式，数据只能单向流动，通常用于父子进程之间或有亲缘关系的进程之间的通信。它有两种类型，匿名管道和命名管道。匿名管道只能在具有亲缘关系的进程之间使用，而命名管道可以在不相关的进程之间进行通信。进程通过读端和写端来进行数据的读取和写入，当一个进程向管道写入数据时，另一个进程可以从管道的读端读取数据。</li>
<li><strong>消息队列</strong>：消息队列是一种异步的通信方式，进程可以将消息发送到消息队列中，而其他进程可以从消息队列中读取消息。消息队列中的消息具有一定的格式和类型，接收进程可以根据消息类型有选择地接收消息。这种方式可以实现不同进程之间的解耦，提高系统的灵活性和可扩展性。</li>
<li><strong>共享内存</strong>：多个进程可以通过映射同一块物理内存到各自的地址空间来实现共享内存通信。进程可以直接对共享内存进行读写操作，就像访问自己的内存一样。为了保证数据的一致性和同步，通常需要结合信号量或互斥锁等同步机制来使用。</li>
<li><strong>信号</strong>：信号是一种用于通知进程发生了某种事件的机制。操作系统可以向进程发送各种信号，如进程终止信号、键盘中断信号等，进程也可以向其他进程发送信号。进程通过捕获和处理信号来响应相应的事件，例如，一个进程可以在接收到特定信号后执行一些清理操作或改变自身的运行状态。</li>
<li><strong>套接字</strong>：套接字是一种网络通信机制，也可以用于本地进程间通信。它提供了一种可靠的、双向的通信方式，进程可以通过套接字发送和接收数据。在本地通信中，通常使用 UNIX 域套接字，它基于文件系统来实现进程间的通信，而不需要通过网络协议栈，因此具有较高的效率。</li>
</ul>
<h4 id="为什么一个线程崩溃会导致当前进程中的其他线程也崩溃"><a href="#为什么一个线程崩溃会导致当前进程中的其他线程也崩溃" class="headerlink" title="为什么一个线程崩溃会导致当前进程中的其他线程也崩溃"></a>为什么一个线程崩溃会导致当前进程中的其他线程也崩溃</h4><p>在多线程编程中，所有线程共享进程地址空间，如果一个线程崩溃可能会导致进程的共享内存修改，进而导致整个进程崩溃。对于线程异常未被捕获也会导致进程终止，从而影响其他线程</p>
<h4 id="为什么-JS-是单线程的"><a href="#为什么-JS-是单线程的" class="headerlink" title="为什么 JS 是单线程的?"></a>为什么 JS 是单线程的?</h4><p>JS 最初是为在浏览器中操作 <code>DOM</code> 元素设计的，如果设计成多线程的就会导致一些节点的操作冲突，就比如一个线程要删除节点而另一个线程中要修改节点时就会导致页面渲染出现问题，这也是为什么在后续中增加了 <code>web worker</code> 进行子线程处理，但是内部不能操作 <code>DOM</code> 的原因</p>
<h4 id="并发和并行的理解"><a href="#并发和并行的理解" class="headerlink" title="并发和并行的理解"></a>并发和并行的理解</h4><h4 id="谈谈你对死锁的理解"><a href="#谈谈你对死锁的理解" class="headerlink" title="谈谈你对死锁的理解"></a>谈谈你对死锁的理解</h4><p>死锁是指在多进程或多线程环境下，两个或多个进程（线程）因竞争资源而形成一种互相等待的僵局，若无外力作用，这些进程（线程）都将无法继续执行。</p>
<ul>
<li><strong>必要条件</strong><ul>
<li><strong>互斥条件</strong>：资源在某一时刻只能被一个进程（线程）所使用，即资源具有排他性。</li>
<li><strong>请求与保持条件</strong>：进程（线程）已经保持了至少一个资源，但又提出了新的资源请求，而新请求的资源被其他进程（线程）占用，此时该进程（线程）保持自己已获得的资源，同时等待新资源的分配。</li>
<li><strong>不可剥夺条件</strong>：进程（线程）所获得的资源在未使用完之前，不能被其他进程（线程）强行剥夺，只能由该进程（线程）自己释放。</li>
<li><strong>循环等待条件</strong>：存在一个进程（线程）资源的循环链，链中的每个进程（线程）都在等待下一个进程（线程）所占用的资源。</li>
</ul>
</li>
<li><strong>解决方法</strong><ul>
<li><strong>预防死锁</strong>：通过破坏死锁产生的四个必要条件中的一个或多个来预防死锁的发生。例如，采用资源静态分配策略，破坏“请求与保持”条件；允许进程（线程）抢占资源，破坏“不可剥夺”条件等。</li>
<li><strong>避免死锁</strong>：在资源分配过程中，使用某种算法来动态地检测系统的资源分配情况，确保系统始终处于安全状态，避免进入死锁状态。例如，银行家算法就是一种经典的避免死锁算法。</li>
<li><strong>检测死锁</strong>：定期检查系统是否存在死锁，如果发现死锁，则采取相应的措施进行解除。检测死锁的方法通常是通过资源分配图来判断是否存在循环等待。</li>
<li><strong>解除死锁</strong>：当检测到死锁后，需要采取措施来解除死锁。常见的方法有剥夺资源和撤销进程（线程），即强行剥夺死锁进程（线程）占用的资源，或者撤销部分或全部死锁进程（线程），以释放资源，打破死锁状态。</li>
</ul>
</li>
</ul>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><p>2XX 成功</p>
<p>200 OK 表示从客户端发来的请求在服务器端被正确处理</p>
<p>204 No content 表示请求成功，但响应报文不含实体的主体部分</p>
<p>3XX 重定向状态</p>
<p>301 永久性重定向，表示资源已被分配给新的 URL</p>
<p>302 暂时重定向，表示资源临时分配给新的 URL</p>
<p>304 表示服务器允许访问资源，但当前浏览器有缓存，直接使用缓存中的数据</p>
<p>4XX 客户端错误状态码</p>
<p>400 请求报文存在语法错误</p>
<p>401 表示发送的请求需要有通过 HTTP 认证的认证信息</p>
<p>403 表示对请求资源的访问被服务器拒绝</p>
<p>404 表示服务器上未找到请求资源</p>
<p>5XX 服务器错误</p>
<p>500 表示服务器端在执行请求时发生了错误</p>
<p>501 表示服务器不支持当前请求所需要的某个功能</p>
<p>502 表示扮演网关/代理的服务器，从上游服务器中接收到的响应是无效的</p>
<p>503 表示服务器暂时处于超负荷或正在进行停机维护，现无法处理请求</p>
<h4 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h4><p><strong><font style="color:#DF2A3F;">封装</font></strong></p>
<p>封装是指将对象的状态（属性）和行为（方法）捆绑在一起，并对外部隐藏对象的内部实现细节。通过访问修饰符（如<code>private</code>、<code>protected</code>、<code>public</code>）来控制对类的成员的访问权限，从而实现信息隐藏。</p>
<p><strong><font style="color:#DF2A3F;">继承</font></strong></p>
<p>继承是指一个类（子类）可以继承另一个类（父类）的属性和方法，从而实现代码的复用和扩展。子类可以拥有父类的非私有成员，并且可以添加自己的属性和方法，或者重写父类的方法。</p>
<p><strong><font style="color:#DF2A3F;">多态</font></strong></p>
<p>多态是指同一个方法调用可以根据对象的不同类型而表现出不同的行为。多态主要通过继承和接口实现，包括方法重载和方法重写。</p>
<h3 id="Java-基础面试题"><a href="#Java-基础面试题" class="headerlink" title="Java 基础面试题"></a>Java 基础面试题</h3><p><strong>基本数据类型和引用数据类型的区别</strong></p>
<p>基本数据类型存储的是具体的值，而引用数据类型存储的是对象的引用（内存地址）。基本数据类型有<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>char</code>、<code>boolean</code>，引用数据类型包括类、接口、数组等。</p>
<p><strong>接口和抽象类的区别</strong></p>
<p>接口中的方法默认是<code>public abstract</code>的，不能有方法体；抽象类中可以有抽象方法，也可以有非抽象方法。一个类可以实现多个接口，但只能继承一个抽象类。接口中只能定义常量，不能定义变量；抽象类中可以定义变量和常量。</p>
<p><strong>重写和重载的区别</strong></p>
<font style="color:rgba(0, 0, 0, 0.85) !important;">重写发生在子类和父类之间，是指子类重新定义父类中已有的方法，以实现与父类不同的行为。当子类对象调用这个被重写的方法时，会执行子类中的方法实现，而不是父类中的方法实现。重载是指在同一个类中，允许存在多个同名方法，但这些方法的参数列表不同。参数列表的不同可以体现在参数的类型、个数或顺序上。调用重载方法时，编译器会根据传入的参数类型和数量来决定调用哪个具体的方法。</font>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://weilaiggbond.github.io/">webbond</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://weilaiggbond.github.io/post/95c2dd30.html">https://weilaiggbond.github.io/post/95c2dd30.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://weilaiggbond.github.io" target="_blank">webbond の 博客</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/cover-four.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/post/8370c532.html" title="前端面经-前端React技术栈"><img class="cover" src="/img/cover-two.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">前端面经-前端React技术栈</div></div><div class="info-2"><div class="info-item-1">react 中常用的 hookuseState:用于在函数组件中声明和管理状态,它返回的是一个数组，其中包括当前状态值和更新状态的函数。 useEffect:用于处理函数组件中的副作用，常用于处理数据获取、订阅事件、定时器函数等。useEffect接收两个参数，一个是函数，一个是用来控制副作用函数执行时机依赖数组。如果没有传递数组参数就默认在每次组件渲染后执行，如果传递了数组参数，就会根据数组中参数发生变化后执行。 useContext:用于访问 react 上下文的值。上下文允许数据在不同组件间共享，而不需要通过组件逐层向下传递 props useCallback:用于记忆组件方法，避免在每次渲染时都要重新创建函数，从而提高性能。useCallback 接收两个参数，分别是记忆化的回调函数 和 依赖项的数组 。主要的应用场景有避免子组件不必要的渲染，和保存回调函数的状态 useMemo:用户缓存计算结果，避免在每次渲染时重新计算。useMemo 接收两个参数，分别是 执行的计算逻辑函数 和 依赖项数组 。useMemo...</div></div></div></a><a class="pagination-related" href="/post/4af591e9.html" title="前端面经-前端工程化"><img class="cover" src="https://images.steamusercontent.com/ugc/16058287679456526865/BC2C7A135ADBC3C56B549EB78EE3ED966CBF88CE/?imw=1920&amp;&amp;ima=fit&amp;impolicy=Letterbox&amp;imcolor=%23000000&amp;letterbox=false" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">前端面经-前端工程化</div></div><div class="info-2"><div class="info-item-1">性能优化前端可以做的性能优化有哪些？使用 CDN 进行静态资源的缓存加速资源的加载速度 对图片/组件进行懒加载，为图片添加上loading=&quot;lazy&quot;,当图片滚动到可视区域时再加载，对于组件懒加载来说可以使用 import()+箭头函数来实现按需导入 使用防抖和节流来减少对服务器/资源的请求，防抖是再延迟期间内只执行最后一次，节流是在规定时间内只执行一次 减少重绘和重排 使用事件委托减少对子元素的操作，事件委托是利用事件冒泡的机制将子元素的操作 利用缓存机制，存储不经常变化的资源来减少对服务器的请求 使用webpack来压缩资源代码体积，删除多余得到代码、注释、简化代码的写法等；使用Tree Shaking删除未使用的代码，使用SplitChunksPlugin进行代码分割（Code Splitting）进行按需加载 LCP 和 FIP LCP 指的事最大内容绘制，常用于衡量页面的加载性能。它测量的是在视口中绘制最大元素所花费的时间，能反映页面主要内容的加载速度，帮助评估用户感知的页面加载完成时间。 FIP 指的是首次重要绘制，用于测量将第一个带注释的...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">webbond</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://weilaiggbond.github.io/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/weilaiGGbond" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-Google-com-%E5%B9%B6%E4%B8%94%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">当浏览器中输入 Google.com 并且按下回车之后发生了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-TCP-%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">为什么 TCP 需要进行三次握手，而不是两次？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS-%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">DNS 协议是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">DNS的查询过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9HTTPS%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">谈谈你对HTTPS的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSL-TLS-%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">SSL&#x2F;TLS 握手的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">TCP和UDP的概念和特点以及区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.8.</span> <span class="toc-text">TCP的三次握手、四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SYN-%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB"><span class="toc-number">1.9.</span> <span class="toc-text">SYN 泛洪攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.10.</span> <span class="toc-text">对浏览器缓存机制的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E3%80%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E3%80%81%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text">强缓存、协商缓存、离线缓存的理解和区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">1.12.</span> <span class="toc-text">浏览器同源策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.13.</span> <span class="toc-text">如何解决跨域问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%80%9A%E4%BF%A1"><span class="toc-number">1.14.</span> <span class="toc-text">浏览器多个标签通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP1-0%E3%80%81HTTP1-1%E3%80%81HTTP2-0%E3%80%81HTTP3-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%90%86%E8%A7%A3"><span class="toc-number">1.15.</span> <span class="toc-text">HTTP1.0、HTTP1.1、HTTP2.0、HTTP3.0之间的区别和理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">HTTP协议和HTTPS协议的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IPV4%E5%92%8CIPV6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.1.</span> <span class="toc-text">IPV4和IPV6的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.</span> <span class="toc-text">HTTP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">GET和POST请求的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-HTTP-%E5%93%8D%E5%BA%94%E5%A4%B4%E5%92%8C%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">2.2.</span> <span class="toc-text">常见的 HTTP 响应头和请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81304%E6%98%AF%E5%A4%9A%E5%A5%BD%E8%BF%98%E6%98%AF%E5%B0%91%E5%A5%BD"><span class="toc-number">2.3.</span> <span class="toc-text">HTTP状态码304是多好还是少好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">常见的 HTTP 请求方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP 协议的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">OSI 七层模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-IP-%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">TCP&#x2F;IP 五层模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.8.</span> <span class="toc-text">TCP 的拥塞控制和流量控制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E7%9A%84%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.9.</span> <span class="toc-text">TCP 的重传机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E7%B2%98%E5%8C%85%E5%A4%84%E7%90%86"><span class="toc-number">2.10.</span> <span class="toc-text">TCP 粘包处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS1-3%E7%9B%B8%E8%BE%83%E4%BA%8E1-2%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA"><span class="toc-number">2.11.</span> <span class="toc-text">TLS1.3相较于1.2的区别在哪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">2.12.</span> <span class="toc-text">浏览器渲染原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8"><span class="toc-number">3.</span> <span class="toc-text">浏览器安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-XSS-%E6%94%BB%E5%87%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.1.</span> <span class="toc-text">谈谈你对 XSS 攻击的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-CSRF-%E6%94%BB%E5%87%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">谈谈 CSRF 攻击的理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.1.</span> <span class="toc-text">谈谈对进程和线程的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%88%86%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">线程和进程之间分别是如何通信的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E4%B9%9F%E5%B4%A9%E6%BA%83"><span class="toc-number">4.3.</span> <span class="toc-text">为什么一个线程崩溃会导致当前进程中的其他线程也崩溃</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-JS-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84"><span class="toc-number">4.4.</span> <span class="toc-text">为什么 JS 是单线程的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.5.</span> <span class="toc-text">并发和并行的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%AD%BB%E9%94%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.6.</span> <span class="toc-text">谈谈你对死锁的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">4.7.</span> <span class="toc-text">HTTP 状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.8.</span> <span class="toc-text">面向对象的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">Java 基础面试题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/4af591e9.html" title="前端面经-前端工程化"><img src="https://images.steamusercontent.com/ugc/16058287679456526865/BC2C7A135ADBC3C56B549EB78EE3ED966CBF88CE/?imw=1920&amp;&amp;ima=fit&amp;impolicy=Letterbox&amp;imcolor=%23000000&amp;letterbox=false" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端工程化"/></a><div class="content"><a class="title" href="/post/4af591e9.html" title="前端面经-前端工程化">前端面经-前端工程化</a><time datetime="2025-04-18T12:03:53.000Z" title="发表于 2025-04-18 20:03:53">2025-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/95c2dd30.html" title="前端面经-前端计网"><img src="/img/cover-four.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端计网"/></a><div class="content"><a class="title" href="/post/95c2dd30.html" title="前端面经-前端计网">前端面经-前端计网</a><time datetime="2025-04-05T12:03:35.000Z" title="发表于 2025-04-05 20:03:35">2025-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/8370c532.html" title="前端面经-前端React技术栈"><img src="/img/cover-two.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端React技术栈"/></a><div class="content"><a class="title" href="/post/8370c532.html" title="前端面经-前端React技术栈">前端面经-前端React技术栈</a><time datetime="2025-03-27T12:03:11.000Z" title="发表于 2025-03-27 20:03:11">2025-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/43b7283f.html" title="前端面经-前端vue技术栈"><img src="/img/cover-three.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端vue技术栈"/></a><div class="content"><a class="title" href="/post/43b7283f.html" title="前端面经-前端vue技术栈">前端面经-前端vue技术栈</a><time datetime="2025-03-22T12:02:53.000Z" title="发表于 2025-03-22 20:02:53">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/bec2f2e9.html" title="前端面经-前端基础"><img src="/img/cover-one.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面经-前端基础"/></a><div class="content"><a class="title" href="/post/bec2f2e9.html" title="前端面经-前端基础">前端面经-前端基础</a><time datetime="2025-03-15T12:02:27.000Z" title="发表于 2025-03-15 20:02:27">2025-03-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">随便讲点什么</p><div class="bg-ad"><div>这里是由 weilaibond 精心搭建的 个人编程学习博客，一个专注于记录「从编程小白到独立开发者」成长轨迹的专属空间。无论你是初入代码世界的萌新，还是正在寻找技术共鸣的同行者，都能在这里找到属于自己的探索坐标。</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://github.com/weilaiGGbond/">weilaibond の github</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">胡乱导航</p><ul class="ft-links"><li><a href="https://weilaiggbond.github.io/about/">关于博主</a><a href="https://weilaiggbond.github.io/archives/">文章归档</a></li><li><a href="https://weilaiggbond.github.io/categories/">文章分类</a><a href="https://weilaiggbond.github.io/tags/">文章标签</a></li></ul></div></div></div></div><div class="copyright">&copy;2022 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> webbond</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>